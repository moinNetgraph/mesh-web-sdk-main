/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export type AccountInfoType =
  | 'firstName'
  | 'middleName'
  | 'lastName'
  | 'accountNumber'
  | 'email'
  | 'mobileNumber'
  | 'companyName'
  | 'countryCode'
  | 'city'
  | 'postalCode'
  | 'address'
  | 'id'
  | 'dateOfBirth'

export interface ApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
}

export type ApiResultStatus =
  | 'ok'
  | 'serverFailure'
  | 'permissionDenied'
  | 'badRequest'
  | 'notFound'
  | 'conflict'
  | 'tooManyRequest'
  | 'locked'
  | 'unavailableForLegalReasons'

export interface Asset {
  symbol?: string | null
  name?: string | null
  type?: 'equity' | 'cryptocurrency'
}

export interface AssetPaginationResponse {
  /** list of items */
  items?: Asset[] | null
  /**
   * Total number of items
   * @format int32
   */
  total?: number
}

export interface AssetPaginationResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: AssetPaginationResponse | null
}

export type AssetType = 'equity' | 'cryptocurrency'

export type AuthFlowStep = 'loginPassword' | 'mfaFlow' | 'faceVerification' | 'createAPIKey' | 'loginQrCode'

export interface AuthenticationFieldDescription {
  /** Name of the field, as expected from the API */
  name?: string | null
  description?: string | null
}

export interface AuthenticationModel {
  authResponse?: B2BBrokerAuthResponse | null
  /** Set of fields that are expected to be provided based on the status of the AuthResponse */
  fields?: AuthenticationFieldDescription[] | null
}

export type AuthenticationSchemeType = 'usernamePassword' | 'oAuth' | 'apiKey' | 'blockchainAddress'

export type B2BAssetType = 'equity' | 'cryptocurrency' | 'option' | 'nft'

export interface B2BBrokerAccountBalance {
  /**
   * Withdrawable cash amount on the account.
   * @format double
   */
  cash?: number | null
  /**
   * Buying power indicating the maximum amount the user can spend to buy assets. E.g. available margin.
   * @format double
   */
  buyingPower?: number | null
  /**
   * Buying power available for placing cryptocurrency orders.
   * @format double
   */
  cryptocurrencyBuyingPower?: number | null
  /** ISO 4217 currency code. */
  currencyCode?: string | null
}

export interface B2BBrokerAccountBalanceModel {
  balances?: B2BBrokerAccountBalance[] | null
  /**
   * Total USD value of all currencies
   * @format double
   */
  totalCashUsdValue?: number | null
  /**
   * Total USD value of all Buying Power
   * @format double
   */
  totalBuyingPowerUsdValue?: number | null
}

export interface B2BBrokerAccountBalanceModelApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerAccountBalanceModel | null
}

export interface B2BBrokerAccountDetailsRequest {
  /**
   * Auth token that allows connecting to the target institution.
   * @minLength 1
   */
  authToken: string
  /**
   * The Id which uniquely identifies the integration.
   * @format uuid
   */
  integrationId: string
}

export interface B2BBrokerAccountDetailsResponse {
  integrationName?: string | null
  firstName?: string | null
  middleName?: string | null
  lastName?: string | null
  accountNumber?: string | null
  email?: string | null
  mobileNumber?: string | null
  companyName?: string | null
  countryCode?: string | null
  city?: string | null
  postalCode?: string | null
  address?: string | null
  idType?: UserIdentificationType | null
  idNumber?: string | null
  /** @format int64 */
  dateOfBirth?: number | null
}

export interface B2BBrokerAccountDetailsResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerAccountDetailsResponse | null
}

export interface B2BBrokerAuthPromptResponse {
  status?: 'failed' | 'redirect' | 'openInBrokerModule'
  redirectLink?: string | null
  linkToken?: string | null
  oAuthToken?: string | null
  errorMessage?: string | null
  displayMessage?: string | null
}

export interface B2BBrokerAuthPromptResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerAuthPromptResponse | null
}

export interface B2BBrokerAuthRequest {
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  phone?: string | null
  username?: string | null
  password?: string | null
  tradePin?: string | null
  countryInfo?: CountryInfo | null
  challengeId?: string | null
  challengeCode?: string | null
  challengeType?: string | null
  /** Used to provide answers to security questions */
  challengeAnswer?: string | null
  mfaCode?: string | null
  mfaType?:
    | 'phone'
    | 'email'
    | 'totp'
    | 'phoneAndEmail'
    | 'requireNextSecurityQuestion'
    | 'readEmail'
    | 'face'
    | 'tradingPin'
    | 'qrCode'
    | 'password'
    | 'roaming'
    | 'mobile'
  deviceInfo?: string | null
  webData?: string | null
  authFlowStep?: AuthFlowStep | null
  key?: string | null
  authToken?: string | null
  redirectLink?: string | null
  confirmationEmail?: string | null
  /**
   * Indicates whether the sensitive fields in this request are encrypted.
   * When set to true, the following fields should be encrypted using Base64 encoding:
   * - Username
   * - Password
   * - Phone
   * - TradePin
   * - ChallengeAnswer
   * - MfaCode
   * - DeviceInfo
   * - ConfirmationEmail
   *
   * Base64 encoding is used to encode these fields into a format that can be safely transmitted and stored.
   */
  isSensitiveFieldsEncrypted?: boolean
  /**
   * Flag indicating that the user is attempting to switch to the next available 2FA
   * method (e.g., Email, Google Authenticator) after failing to complete or canceling
   * the current verification method (e.g., Roaming 2FA).
   *
   * This field is primarily used for Robinhood and BinanceInternationalDirect on the DeviceConfirmationPage
   * when a user clicks the "Try Another Way" button. It informs the backend to move to the next
   * MFA method instead of retrying the current one.
   */
  isTryingAnotherWay?: boolean
}

export interface B2BBrokerAuthResponse {
  /** Status of the request */
  status?:
    | 'failed'
    | 'challengeFailed'
    | 'succeeded'
    | 'challengeIssued'
    | 'mfaRequired'
    | 'openInBrokerModule'
    | 'delayed'
    | 'deviceConfirmationRequired'
    | 'emailVerification'
    | 'emailReceived'
    | 'captchaChallenge'
    | 'faceVerification'
    | 'bindMfaRequired'
    | 'apiKeyGenerationError'
    | 'qrCodeRequired'
    | 'qrCodeExpired'
    | 'deviceLoginVerified'
  mfaType?: MfaType | null
  /** The AuthFlowStep is used to determine which state the authentication is in, for initial requests without MFA verification the value should be LoginPassword and when calling with MFA code it should be MfaFlow (currently used for BinanceInternationalDirect only). */
  authFlowStep?: AuthFlowStep | null
  /** Qr code used to scan and solve facial verification (currently used for BinanceInternationalDirect only). */
  qrCode?: string | null
  qrCodeLink?: string | null
  qrCodeLinkIOS?: string | null
  /** Id of the challenge, relevant when the status is `ChallengeIssued` */
  challengeId?: string | null
  challengeText?: string | null
  /**
   * Life span of the challenge
   * @format int32
   */
  challengeExpiresInSeconds?: number | null
  errorMessage?: string | null
  displayMessage?: string | null
  /** @deprecated */
  accessToken?: string | null
  /** @deprecated */
  refreshToken?: string | null
  /** @format int32 */
  expiresInSeconds?: number | null
  /** @format int32 */
  refreshTokenExpiresInSeconds?: number | null
  /** @deprecated */
  account?: BrokerAccount | null
  accountTokens?: BrokerAccountTokens[] | null
  requiresReauthentication?: boolean | null
  email?: string | null
  allocatedIPAddress?: string | null
}

export interface B2BBrokerAuthResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerAuthResponse | null
}

export type B2BBrokerAuthStatus = 'failed' | 'succeeded' | 'mfaRequired'

export interface B2BBrokerConversionFeature {
  supported?: boolean
  supportsPreview?: boolean
  supportedCryptocurrencySymbols?: string[] | null
  supportedFiatCurrencies?: string[] | null
}

export interface B2BBrokerCreateCryptocurrencyTransactionResponse {
  /** Transaction Id by the financial institution */
  transactionId?: string | null
  failed?: boolean
  mfaType?: MfaType | null
  verificationSteps?: MfaType[] | null
  qrCode?: string | null
  qrCodeLink?: string | null
  /** Status of the operation */
  status?:
    | 'unknown'
    | 'failed'
    | 'frozen'
    | 'succeeded'
    | 'mfaRequired'
    | 'pending'
    | 'expired'
    | 'canceled'
    | 'waitingForSignature'
    | 'waitingForClearing'
    | 'awaitingApproval'
    | 'awaitingConfirmation'
    | 'awaitingVerification'
    | 'rejected'
    | 'pendingCancel'
    | 'emailVerification'
    | 'deviceConfirmationRequired'
    | 'mfaFailed'
    | 'addressWhitelistRequired'
    | 'secondMfaRequired'
    | 'emailConfirmationApprovalRequired'
  /** Details of the current status of the transfer, as provided by the financial institution */
  statusDetails?: string | null
  /** Details of the created transaction */
  transaction?: B2BBrokerCryptocurrencyTransaction | null
  fallbackMfaAvailable?: boolean
  challengeId?: string | null
}

export interface B2BBrokerCreateCryptocurrencyTransactionResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerCreateCryptocurrencyTransactionResponse | null
}

export interface B2BBrokerCreateOrderRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Symbol to trade. For example, `AAPL` or `ETH`
   * @minLength 1
   */
  symbol: string
  /**
   * Symbol to use for payment, defaults to `USD`.
   * @minLength 1
   */
  paymentSymbol: string
  /**
   * Amount of purchase.
   * @format double
   */
  amount: number
  /**
   * Price of the unit, used for `Limit` and `StopLoss` orders.
   * @format double
   */
  price?: number
  /** Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly. */
  isCryptocurrency: boolean
  /** Indicates whether the `PaymentSymbol` is fiat or cryptocurrency */
  paymentIsCryptocurrency: boolean
  /** @deprecated */
  amountIsFiat?: boolean | null
  /**
   * @deprecated
   * @format double
   */
  amountInFiat?: number | null
  /**
   * This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be
   * performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and
   * `SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`
   * value is passed.
   */
  amountIsInPaymentSymbol: boolean
  /**
   * Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`
   * and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
   * @format double
   */
  amountInPaymentSymbol?: number | null
  /** Specifies if the extended trading hours should be used. */
  extendedHours?: boolean
  orderType: 'market' | 'limit' | 'stopLoss'
  timeInForce: 'goodTillCanceled' | 'immediateOrCancel' | 'fillOrKill' | 'goodForDay' | 'postOnly' | 'unknown'
  /** MFA Code to create an order (requested by Kraken if MFA is enabled in user settings) */
  mfaCode?: string | null
}

export interface B2BBrokerCreateOrderResult {
  /** Id of the order, as returned from the financial institution. Can be used to get the status of the order. */
  orderId?: string | null
  /** Type of the institution. */
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Side of the order. */
  side?: 'unknown' | 'buy' | 'sell'
  /**
   * Amount of the order.
   * @format double
   */
  amount?: number
  /**
   * Unit price of the asset.
   * @format double
   */
  price?: number | null
  /**
   * Total value of the order.
   * @format double
   */
  value?: number | null
  /**
   * Optional Fee taken by the financial institution.
   * @format double
   */
  fee?: number | null
  /**
   * Timestamp of the order.
   * @format int64
   */
  timestamp?: number
  /** Status of the order. */
  status?: 'unknown' | 'inProgress' | 'cancelled' | 'rejected' | 'failed' | 'success' | 'partiallyFilled' | 'expired'
  /** Text details of the order, if additionally returned from the financial institution. */
  statusDetails?: string | null
  /** Value that indicates how long the order will remain active before it is executed or expires. */
  timeInForce?: BrokerOrderTimeInForceType | null
  /** Optional pair of symbols, as returned from the financial institution. Can be required to obtain the status of the order by some institutions. */
  symbolPair?: string | null
  /** Id of the parent order, applicable to some institutions if the order was executed in several trades. */
  parentOrderId?: string | null
  /** List of trades, provided only if the order was executed in several trades. */
  trades?: B2BBrokerOrderTrade[] | null
  /** A message describing the error if the order wasn't placed. */
  errorMessage?: string | null
  /** A user-friendly display message that can be presented to the end user. */
  displayMessage?: string | null
}

export interface B2BBrokerCreateOrderResultApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerCreateOrderResult | null
}

export interface B2BBrokerCryptoPairTradeFeatureOrderType {
  /** Specifies if this order type is supported for this integration. */
  supported?: boolean
  /** The list of supported Time-in-force instructions for this order type. */
  supportedTimeInForceList?: BrokerPairTradeTimeInForceType[] | null
  /**
   * Specifies if this order type supports placing buy orders in base symbol amounts. For example,
   * if payment/quote symbol is USD, base symbol is ETH, and this capability is supported, then the API can be instructed to buy 1 or other amount of ETH.
   */
  supportsPlacingBuyOrdersInBaseSymbolAmount?: boolean
  /**
   * Specifies if this order type supports placing sell orders in base symbol amounts. For example,
   * if payment/quote symbol is USD, base symbol is ETH, and this capability is supported, then the API can be instructed to sell 1 or other amount of ETH.
   */
  supportsPlacingSellOrdersInBaseSymbolAmount?: boolean
  /**
   * Specifies if this order type supports placing buy orders in quote symbol amounts. For example,
   * if payment/quote symbol is USDC, and this capability is supported, then the API can be instructed to buy asset for 10 USDC or other amount.
   */
  supportsPlacingBuyOrdersInQuoteSymbolAmount?: boolean
  /**
   * Specifies if this order type supports placing sell orders in quote symbol amounts. For example,
   * if payment/quote symbol is USDC, and this capability is supported, then the API can be instructed to sell asset for 10 USDC or other amount.
   */
  supportsPlacingSellOrdersInQuoteSymbolAmount?: boolean
}

export interface B2BBrokerCryptocurrencyDepositAddressResponse {
  symbol?: string | null
  address?: string | null
  chain?: string | null
  memo?: string | null
  minimumDepositAmount?: string | null
  /** @format uuid */
  networkId?: string | null
  brokerResponseStatus?: BrokerResponseStatus | null
  errorMessage?: string | null
}

export interface B2BBrokerCryptocurrencyDepositAddressResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerCryptocurrencyDepositAddressResponse | null
}

export interface B2BBrokerCryptocurrencyPairTradeFeature {
  supported?: boolean
  supportedCryptocurrencySymbols?: string[] | null
  supportedFiatCurrencies?: string[] | null
  supportedTradingPairs?: string[] | null
  marketType?: B2BBrokerCryptoPairTradeFeatureOrderType | null
  limitType?: B2BBrokerCryptoPairTradeFeatureOrderType | null
}

export interface B2BBrokerCryptocurrencySymbolDetailsResponse {
  /** Requested symbol */
  symbol?: string | null
  /** Supported address types */
  addressTypes?: CryptocurrencyAddressType[] | null
  /** Supported chains. One of the values should be provided to execute transfers */
  chains?: BrokerCryptocurrencyChain[] | null
}

export interface B2BBrokerCryptocurrencySymbolDetailsResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerCryptocurrencySymbolDetailsResponse | null
}

export interface B2BBrokerCryptocurrencyTransaction {
  /** Identifier of the transfer, if provided by the financial institution */
  id?: string | null
  /** Current status of the transaction */
  status?:
    | 'unknown'
    | 'failed'
    | 'frozen'
    | 'succeeded'
    | 'mfaRequired'
    | 'pending'
    | 'expired'
    | 'canceled'
    | 'waitingForSignature'
    | 'waitingForClearing'
    | 'awaitingApproval'
    | 'awaitingConfirmation'
    | 'awaitingVerification'
    | 'rejected'
    | 'pendingCancel'
    | 'emailVerification'
    | 'deviceConfirmationRequired'
    | 'mfaFailed'
    | 'addressWhitelistRequired'
    | 'secondMfaRequired'
    | 'emailConfirmationApprovalRequired'
  /** Details of the current status of the transfer, as provided by the financial institution */
  statusDetails?: string | null
  /** The direction of the transaction */
  type?: 'unknown' | 'deposit' | 'withdrawal'
  /** Address where the transaction was sent from */
  fromAddress?: string | null
  /** Address where the transaction was sent to */
  targetAddress?: string | null
  /** Ticker of the transaction */
  symbol?: string | null
  /** Crypto Chain the transaction belongs to */
  chain?: string | null
  /** Memo of the transaction (also called "Tag") */
  memo?: string | null
  /** Hash of the transaction */
  hash?: string | null
  /**
   * Full amount affected the balance, typically transaction amount plus fee
   * @format double
   */
  amount?: number
  /**
   * Transaction amount
   * @format double
   */
  transactionAmount?: number | null
  /**
   * Unix timestamp in seconds indicating when the transaction was created
   * @format int64
   */
  createdTimestamp?: number
  /**
   * Unix timestamp in seconds indicating when the transaction was last updated
   * @format int64
   */
  updatedTimestamp?: number
  /** Fee taken by the network */
  networkTransactionFee?: BrokerCryptocurrencyTransactionNetworkFee | null
  /**
   * Fee taken by the financial institution
   * @format double
   */
  transferFee?: number | null
  /**
   * Number of confirmations on the blockchain
   * @format int64
   */
  confirmations?: number | null
  /** Name of the executed blockchain function based on decoded input data */
  blockchainMethodName?: string | null
  /** Executed blockchain function based on decoded input data. Not guaranteed to be identified */
  blockchainMethod?:
    | 'transfer'
    | 'swap'
    | 'mint'
    | 'withdraw'
    | 'claimRewards'
    | 'deposit'
    | 'approve'
    | 'forgeToken'
    | 'multicall'
    | 'migrateToken'
    | 'claim'
    | 'openSeaTransfer'
    | 'cancel'
    | 'commit'
    | 'run'
    | 'repay'
    | 'execute'
    | 'stake'
    | 'merge'
}

export interface B2BBrokerCryptocurrencyTransactionApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerCryptocurrencyTransaction | null
}

export interface B2BBrokerOptionData {
  /** Type of option */
  optionType?: 'unknown' | 'call' | 'put'
  /** Direction of option */
  direction?: 'unknown' | 'buyToOpen' | 'buyToClose' | 'sellToOpen' | 'sellToClose' | 'buyToCover' | 'sellShort'
  /**
   * Option strike price
   * @format double
   */
  strikePrice?: number
  /**
   * Option expiration timestamp
   * @format int64
   */
  expirationTimestamp?: number
  /**
   * Number of shares covered by option
   * @format double
   */
  numberOfSharesInContract?: number
  /** Option complex order strategy type */
  complexOrderStrategyType?: string | null
}

export interface B2BBrokerOrder {
  /** Transaction id, as provided by the institution */
  id?: string | null
  /** Side of the transaction */
  side?: 'unknown' | 'buy' | 'sell'
  /** Traded symbol */
  symbol?: string | null
  /** Name of the traded asset */
  name?: string | null
  /** Type of the traded asset */
  assetType?: 'equity' | 'cryptocurrency' | 'option' | 'nft'
  /**
   * Fiat or cryptocurrency symbol used for payment. For transactions with types `ConversionFrom` or `ConversionTo`
   * this field specifies the target symbol. For example, for `ETH` to `BTC` conversion, the transaction type is `ConversionTo`, the `Symbol` field is `ETH` and the `PaymentSymbol` is `BTC`
   */
  paymentSymbol?: string | null
  /** Indicates if the payment was performed with fiat or crypto currency */
  paymentType?: 'fiat' | 'cryptocurrency'
  /**
   * Executed amount
   * @format double
   */
  amount?: number | null
  /**
   * Price of the unit
   * @format double
   */
  price?: number | null
  /**
   * Order Fee, taken by the financial institution
   * @format double
   */
  fee?: number | null
  /**
   * Total value
   * @format double
   */
  value?: number | null
  /**
   * Unix timestamp in seconds indicating when the order was placed or the transaction was created
   * @format int64
   */
  createdTimestamp?: number
  /**
   * Unix timestamp in seconds indicating when the transaction was last updated (e.g. executed)
   * @format int64
   */
  updatedTimestamp?: number
  /** Status of the transaction */
  status?: 'unknown' | 'inProgress' | 'cancelled' | 'rejected' | 'failed' | 'success' | 'partiallyFilled' | 'expired'
  /** Status text, as provided by the institution */
  statusDetails?: string | null
  /** Type of the placed order */
  orderType?: BrokerOrderPlaceType | null
  /** Time in force of the order: a value indicating how long the order remains active before it is executed or expires */
  timeInForce?: BrokerOrderTimeInForceType | null
  /** Type of the integration */
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Type of the transaction */
  transactionType?:
    | 'order'
    | 'conversionTo'
    | 'conversionFrom'
    | 'ownAccountDeposit'
    | 'ownAccountWithdraw'
    | 'stake'
    | 'dividendReinvestment'
    | 'interest'
    | 'reward'
    | 'unknown'
    | 'conversionToFiat'
    | 'conversionFromFiat'
  /** Id of the parent order, applicable to some institutions */
  parentOrderId?: string | null
  /** Additional details for options */
  optionDetails?: B2BBrokerOptionData | null
}

export interface B2BBrokerOrderApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerOrder | null
}

export interface B2BBrokerOrderListRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * The cursor to retrieve the next page of transactions.
   * Providing it will cause the response to only return changes after this update.
   * If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
   */
  cursor?: string | null
  /**
   * Number of records to include in the response.
   *
   * Default: `100`
   *
   * Maximum: `250`
   * @format int32
   */
  count?: number
  /** Return orders of this statuses only. If this field is not provided, orders with all available statuses will be returned. */
  statuses?: BrokerOrderStatus[] | null
  /**
   * Return orders created after this timestamp.
   * If this field is not provided, orders will be returned according to the default of the institution.
   * @format int64
   */
  from?: number | null
}

export interface B2BBrokerOrderListResponse {
  /** List of obtained transactions. */
  transactions?: B2BBrokerOrder[] | null
  /** The cursor to retrieve the next page of transactions. */
  cursor?: string | null
  /**
   * Total amount of records.
   * @format int64
   */
  total?: number
  /**
   * Earliest transaction timestamp.
   * @format int64
   */
  earliestTimestamp?: number
}

export interface B2BBrokerOrderListResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerOrderListResponse | null
}

export type B2BBrokerOrderPaymentSymbolType = 'fiat' | 'cryptocurrency'

export interface B2BBrokerOrderRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** @minLength 1 */
  id: string
  /** Should be provided for Coinbase. */
  side?: BrokerOrderType | null
  /** Some Stock and Crypto symbols can intersect, so we need to explicitly specify what type of asset is requested to be bought. */
  isCryptocurrency: boolean
  /** Symbol pair of the order (requested by some brokers). */
  symbolPair?: string | null
  /** MFA Code to cancel an order (requested by Kraken if MFA is enabled in user settings) */
  mfaCode?: string | null
}

export interface B2BBrokerOrderSymbolInfo {
  /** Specifies if the fractional trading is allowed for the provided symbol */
  fractionalTradingAllowance?:
    | 'fractionalTradingAllowed'
    | 'fractionalTradingNotAllowed'
    | 'tradingNotAllowed'
    | 'fractionalTradingPossiblyAllowed'
  /**
   * Minimum allowed order value
   * @format double
   */
  minimumOrderValue?: number
  /**
   * Maximum number of decimal digits accepted by the symbol
   * @format int32
   */
  precisionScale?: number | null
}

export interface B2BBrokerOrderSymbolInfoApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerOrderSymbolInfo | null
}

export interface B2BBrokerOrderTrade {
  tradeId?: string | null
  /** @format double */
  amount?: number | null
  /** @format double */
  value?: number | null
  /** @format double */
  price?: number | null
  /** @format double */
  fee?: number | null
  orderCategory?: 'order' | 'trade' | 'ledger' | 'historyAction'
}

export interface B2BBrokerPreviewOrderResult {
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** @format double */
  fee?: number | null
  feeText?: string | null
  /** @format double */
  amount?: number
  side?: 'unknown' | 'buy' | 'sell'
  status?: 'success' | 'failed'
  errorMessage?: string | null
  paymentSymbol?: string | null
  paymentIsCryptocurrency?: boolean
  /** @format double */
  estimatedUnitPrice?: number | null
}

export interface B2BBrokerPreviewOrderResultApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerPreviewOrderResult | null
}

export interface B2BBrokerRefreshTokenResponse {
  status?: 'failed' | 'succeeded' | 'mfaRequired'
  errorMessage?: string | null
  displayMessage?: string | null
  /** @deprecated */
  account?: BrokerAccount | null
  /** @deprecated */
  accessToken?: string | null
  /** @deprecated */
  refreshToken?: string | null
  /** @format int32 */
  expiresInSeconds?: number | null
  /** @format int32 */
  refreshTokenExpiresInSeconds?: number | null
  brokerAccountTokens?: BrokerAccountTokens[] | null
}

export interface B2BBrokerRefreshTokenResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerRefreshTokenResponse | null
}

export interface B2BBrokerSymbolInfoForOrderRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Symbol to trade. For example, `AAPL` or `ETH`
   * @minLength 1
   */
  symbol: string
  /**
   * Symbol to use for payment, defaults to `USD`.
   * @minLength 1
   */
  paymentSymbol: string
  /**
   * Amount of purchase.
   * @format double
   */
  amount: number
  /**
   * Price of the unit, used for `Limit` and `StopLoss` orders.
   * @format double
   */
  price?: number
  /** Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly. */
  isCryptocurrency: boolean
  /** Indicates whether the `PaymentSymbol` is fiat or cryptocurrency */
  paymentIsCryptocurrency: boolean
  /** @deprecated */
  amountIsFiat?: boolean | null
  /**
   * @deprecated
   * @format double
   */
  amountInFiat?: number | null
  /**
   * This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be
   * performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and
   * `SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`
   * value is passed.
   */
  amountIsInPaymentSymbol: boolean
  /**
   * Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`
   * and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
   * @format double
   */
  amountInPaymentSymbol?: number | null
  /** Specifies if the extended trading hours should be used. */
  extendedHours?: boolean
  orderType: 'market' | 'limit' | 'stopLoss'
  timeInForce: 'goodTillCanceled' | 'immediateOrCancel' | 'fillOrKill' | 'goodForDay' | 'postOnly' | 'unknown'
  /** MFA Code to create an order (requested by Kraken if MFA is enabled in user settings) */
  mfaCode?: string | null
  side?: BrokerOrderType | null
}

export interface B2BBrokerTradingFeature {
  supported?: boolean
  supportsFiatCurrencyPayment?: boolean
  supportsCryptocurrencyPayment?: boolean
  supportsMarginOrders?: boolean
  supportedCryptocurrencySymbols?: string[] | null
  supportedCryptocurrencySymbolsForPayment?: string[] | null
  supportedFiatCurrencies?: string[] | null
  marketType?: B2BBrokerTradingFeatureOrderType | null
  limitType?: B2BBrokerTradingFeatureOrderType | null
  stopLossType?: B2BBrokerTradingFeatureOrderType | null
}

export interface B2BBrokerTradingFeatureInfo {
  /** Type of the integration. */
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Account Id of the integration. */
  accountId?: string | null
  /** Model, describing the ability to place cryptocurrency orders. */
  cryptocurrencyOrders?: B2BBrokerTradingFeature | null
  /** Model, describing the ability to place equity orders. */
  stockOrders?: B2BBrokerTradingFeature | null
  /** Model, describing the asset pair trading ability */
  cryptocurrencyAssetPairTrading?: B2BBrokerCryptocurrencyPairTradeFeature | null
  /** Model, describing the conversion ability */
  cryptocurrencyConversion?: B2BBrokerConversionFeature | null
  /** Status of the request. */
  status?: 'succeeded' | 'failed' | 'notAuthorized'
  /**
   * Indicates if the preview of orders (`preview order execution` endpoint) is provided by the institution.
   * This allows to validate the order using the API of the institution. If the order preview is not supported,
   * Front API validates the order without calling the institution's API.
   */
  supportsOrderPreview?: boolean
  /** Supports getting price information directly from the institution. */
  supportsPriceQuotes?: boolean
  /** Indicates if it is possible to cancel the placed order, while it's in the `InProgress` status. */
  supportsOrderCancellation?: boolean
  /** Indicates if the integration is available. */
  isIntegrationUp?: boolean
  /** Indicates if trading is generally supported at this time. */
  isTradingSupported?: boolean
  /** List of fiat balances of the account. */
  fiatBalances?: B2BBrokerAccountBalance[] | null
  /**
   * Limit for history records
   * @format int32
   */
  historyRecordLimit?: number | null
  /** Indicates whether the current exchange uses spreads as costs for trading */
  usesSpreads?: boolean
}

export interface B2BBrokerTradingFeatureInfoApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerTradingFeatureInfo | null
}

export interface B2BBrokerTradingFeatureOrderType {
  /** Specifies if this order type is supported for this integration. */
  supported?: boolean
  /** Specifies if this order type supports buying or selling in fractional amounts. If this value is `false`, then only whole shares can be traded. */
  supportsFractionalShares?: boolean
  /** Indicates if pre-market trading or after-hours trading is supported. */
  supportsExtendedMarketHours?: boolean
  /** @deprecated */
  readonly supportsPlacingBuyOrdersInFiatAmount?: boolean
  /** @deprecated */
  readonly supportsPlacingSellOrdersInFiatAmount?: boolean
  /** The list of supported Time-in-force instructions for this order type. */
  supportedTimeInForceList?: BrokerOrderTimeInForceType[] | null
  /**
   * Specifies if this order type supports placing buy orders in payment/quote symbol amounts. For example,
   * if payment/quote symbol is USD, and this capability is supported, then the API can be instructed to buy asset for $10 or other dollar amount.
   */
  supportsPlacingBuyOrdersInPaymentSymbolAmount?: boolean
  /**
   * Specifies if this order type supports placing sell orders in payment/quote symbol amounts. For example,
   * if payment/quote symbol is USD, and this capability is supported, then the API can be instructed to sell asset for $10 or other dollar amount.
   */
  supportsPlacingSellOrdersInPaymentSymbolAmount?: boolean
  /**
   * Specifies if this order type supports placing buy orders in base symbol amounts. For example,
   * if payment/quote symbol is USD, base symbol is AAPL, and this capability is supported, then the API can be instructed to buy 1 or other amount of AAPL.
   */
  supportsPlacingBuyOrdersInBaseSymbolAmount?: boolean
  /**
   * Specifies if this order type supports placing sell orders in base symbol amounts. For example,
   * if payment/quote symbol is USD, base symbol is AAPL, and this capability is supported, then the API can be instructed to sell 1 or other amount of AAPL.
   */
  supportsPlacingSellOrdersInBaseSymbolAmount?: boolean
}

export interface B2BBrokerTransactionsListModel {
  /** List of obtained transfers. */
  transfers?: B2BBrokerCryptocurrencyTransaction[] | null
  /**
   * Total amount of records.
   * @format int64
   */
  total?: number
  /** The cursor to retrieve the next page of transfers. */
  cursor?: string | null
  /**
   * Earliest transfer timestamp.
   * @format int64
   */
  earliestTimestamp?: number
}

export interface B2BBrokerTransactionsListModelApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokerTransactionsListModel | null
}

export interface B2BBrokersHealthStatus {
  /** Type of the integration */
  type?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Name of the integration */
  name?: string | null
  /** Is the communication with the integration up */
  isUp?: boolean
  /** Description of the outage */
  description?: string | null
  /**
   * Unix timestamp in seconds indicating when the outage occurred
   * @format int64
   */
  downTimeStart?: number | null
  /**
   * Unix timestamp in seconds indicating expected end of the outage
   * @format int64
   */
  downTimeEnd?: number | null
  /** Get products supported by the financial institution */
  supportedProducts?: BrokerFeature[] | null
  /** Short information about DeFiWallet */
  deFiWalletData?: DeFiWalletHealthStatusInfo | null
}

export interface B2BBrokersHealthStatusListApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BBrokersHealthStatus[] | null
}

export interface B2BFiatPortfolioModel {
  /** List of aggregated fiat balances */
  fiatBalances?: PortfolioFiatBalance[] | null
}

export interface B2BFiatPortfolioModelApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BFiatPortfolioModel | null
}

export interface B2BNftPosition {
  /** @format double */
  amount?: number
  /** @format double */
  costBasis?: number | null
  contractAddress?: string | null
  name?: string | null
  description?: string | null
  marketplaceId?: string | null
  tokenId?: string | null
  marketplacePermalink?: string | null
  addressType?:
    | 'ethAddress'
    | 'btcAddress'
    | 'ltcAddress'
    | 'solAddress'
    | 'algoAddress'
    | 'celoAddress'
    | 'cardanoAddress'
    | 'polygonAddress'
    | 'bnbAddress'
    | 'elrondAddress'
    | 'neoAddress'
    | 'xrpAddress'
    | 'flowAddress'
    | 'harmonyOneAddress'
    | 'tronAddress'
    | 'dogeAddress'
    | 'opAddress'
}

export interface B2BOptionPosition {
  /** Symbol of the underlying stock */
  symbol?: string | null
  /**
   * Amount of options
   * @format double
   */
  amount?: number
  /**
   * Total average paid price
   * @format double
   */
  averageOpenPrice?: number
  /** Side of the option, buy or sell */
  direction?: 'unknown' | 'buyToOpen' | 'buyToClose' | 'sellToOpen' | 'sellToClose' | 'buyToCover' | 'sellShort'
  /** @format int64 */
  createdTimestamp?: number
  /** @format int64 */
  updatedTimestamp?: number
  /**
   * Number of shares of the underlying stock
   * @format double
   */
  numberOfSharesInContract?: number
  /** Type of the option, put or call */
  optionType?: 'unknown' | 'call' | 'put'
  /**
   * The last day that the option contract is valid
   * @format int64
   */
  expirationTimestamp?: number
  /**
   * The price at which a put or call option can be exercised
   * @format double
   */
  strikePrice?: number
}

export interface B2BPortfolioModel {
  /**
   * Amount of money spent to buy all positions of the portfolio.
   * @format double
   */
  portfolioCostBasis?: number | null
  /**
   * Actual performance based on the cost basis.
   * @format double
   */
  actualPortfolioPerformance?: number | null
  /**
   * Total USD portfolio value of all equities (sum(equity price * equity amount)). Does not include cash balance.
   * @format double
   */
  equitiesValue?: number
  /**
   * Total USD value of all cryptocurrencies in the portfolio.
   * @format double
   */
  cryptocurrenciesValue?: number
  /**
   * Total USD value of all NFTs in the portfolio.
   * @format double
   */
  nftsValue?: number
  /** List of equity positions */
  equityPositions?: PositionWithReturn[] | null
  /** List of cryptocurrency positions */
  cryptocurrencyPositions?: PositionWithReturn[] | null
  /** List of NFT positions */
  nftPositions?: NftPositionWithMarketValues[] | null
}

export interface B2BPortfolioModelApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BPortfolioModel | null
}

export interface B2BPriceInfo {
  /** @format double */
  price?: number
  /** @format int64 */
  timestamp?: number
}

export interface B2BPriceInfoApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: B2BPriceInfo | null
}

export type B2BTransactionType =
  | 'order'
  | 'conversionTo'
  | 'conversionFrom'
  | 'ownAccountDeposit'
  | 'ownAccountWithdraw'
  | 'stake'
  | 'dividendReinvestment'
  | 'interest'
  | 'reward'
  | 'unknown'
  | 'conversionToFiat'
  | 'conversionFromFiat'

export interface BalanceBrokerBaseRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```ETrade```
   * ```Alpaca```
   * ```WeBull```
   * ```Stash```
   * ```InteractiveBrokers```
   * ```Public```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```Etoro```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Acorns```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```Vanguard```
   * ```BinanceInternationalDirect```
   * ```BitfinexDirect```
   * ```Bybit```
   * ```Paxos```
   * ```CoinbasePrime```
   * ```BtcTurkDirect```
   * ```KuCoinDirect```
   * ```OkxOAuth```
   * ```ParibuDirect```
   * ```RobinhoodConnect```
   * ```BlockchainCom```
   * ```BitsoDirect```
   * ```BybitDirect```
   * ```ParibuOAuth```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
}

export interface BrokerAccount {
  /** @format uuid */
  meshAccountId?: string
  /**
   * @deprecated
   * @format uuid
   */
  readonly frontAccountId?: string
  accountId?: string | null
  accountName?: string | null
  /**
   * Buying power of the account. Typically consists of cash plus available margin.
   * For non-margin accounts fund contains cash only
   * @format double
   */
  fund?: number | null
  /**
   * Cash balance in USD
   * @format double
   */
  cash?: number | null
  /**
   * Indicates if this account was already connected by the current user and device.
   * Can be null.
   */
  isReconnected?: boolean | null
  /** The list of all asset balances of account */
  balances?: BrokerFiatBalance[] | null
}

export interface BrokerAccountTokens {
  account?: BrokerAccount | null
  accessToken?: string | null
  refreshToken?: string | null
  /** Token identifier provided by Mesh when the actual integration's token is managed by Mesh's Token Management System. */
  tokenId?: string | null
}

export type BrokerAuthPromptStatus = 'failed' | 'redirect' | 'openInBrokerModule'

export type BrokerAuthStatus =
  | 'failed'
  | 'challengeFailed'
  | 'succeeded'
  | 'challengeIssued'
  | 'mfaRequired'
  | 'openInBrokerModule'
  | 'delayed'
  | 'deviceConfirmationRequired'
  | 'emailVerification'
  | 'emailReceived'
  | 'captchaChallenge'
  | 'faceVerification'
  | 'bindMfaRequired'
  | 'apiKeyGenerationError'
  | 'qrCodeRequired'
  | 'qrCodeExpired'
  | 'deviceLoginVerified'

export interface BrokerAuthenticationScheme {
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Type of authentication for the integration. */
  authenticationSchemeType?: 'usernamePassword' | 'oAuth' | 'apiKey' | 'blockchainAddress'
  /** Set of fields that should be provided in the initial POST `authenticate` request. */
  initialAuthenticationModel?: AuthenticationModel | null
  /** Set of fields that should be provided depending on the status of the response of the first POST `authenticate` request. */
  authenticationSteps?: AuthenticationModel[] | null
  /** Supported MFA schemes, can be none or multiple. */
  mfaSchemes?: MfaScheme[] | null
  /** Optional URL with the instructions explaining how to create a set of API key/secret for the integration, can be shown to the end user. */
  instructionsUrl?: string | null
}

export interface BrokerAuthenticationSchemeIReadOnlyCollectionApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: BrokerAuthenticationScheme[] | null
}

export interface BrokerBaseRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
}

export interface BrokerCreateCryptocurrencyTransactionRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Additional data to send on-chain (optional, depends on an integration) */
  data?: string | null
  /**
   * Target address to transfer the asset to
   * @minLength 1
   */
  targetAddress: string
  /**
   * Amount to transfer
   * @format double
   */
  amount?: number
  /**
   * On-chain fee (optional, depends on an integration)
   * @format double
   */
  fee?: number
  /**
   * Type of the address of symbol to be transferred. Providing `EthAddress` will initiate a transfer of ETH over Ethereum blockchain.
   * Can be used instead of `Symbol` and `Chain` fields.
   * To transfer assets over non-default chains (e.g. sending USDT over ERC20) please `Symbol` and `Chain` fields.
   */
  addressType?: CryptocurrencyAddressType | null
  /** 2 Factor auth code (optional, depends on an integration) */
  mfaCode?: string | null
  /**
   * Travel rule transaction id (optional, depends on an integration)
   * @format int32
   */
  travelRuleTransactionId?: number | null
  /** 2 Factor auth type (optional, depends on an integration) */
  mfaType?: MfaType | null
  verificationSteps?: MfaType[] | null
  /** Password or pass-phrase, required to send transfers (optional, depends on an integration) */
  password?: string | null
  /**
   * Custom chain name, required by some of the integrations. E.g. USDT can be sent over USDT-ERC20, USDT-TRC20, and USDT-Omni.
   * Can be used to transfer assets over non-default chains (e.g. sending USDT over ERC20).
   * Please use `symbol/details` endpoint to get the list of all possible chains.
   */
  chain?: string | null
  /** Memo (also called "Tag") - address remark. */
  memo?: string | null
  /** Symbol to be transferred. Can be provided instead of the `AddressType` field. */
  symbol?: string | null
  challengeId?: string | null
  tryAnotherMfa?: boolean
  travelRuleOptions?: TransferTravelRuleOptions | null
}

export interface BrokerCryptocurrencyChain {
  /** Name of the chain, should be provided when initiating a transfer */
  chain?: string | null
  feeDescription?: string | null
  /** Notes or tips provided by the integration */
  notes?: string | null
  /** @format double */
  fee?: number | null
  /** @format double */
  minWithdrawAmount?: number | null
  /** @format double */
  maxWithdrawAmount?: number | null
  /** @format uuid */
  networkId?: string | null
}

export interface BrokerCryptocurrencyDepositAddressRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Symbol of the required cryptocurrency, e.g. ETH or BTC.
   * Can be used instead of the `AddressType` field.
   */
  symbol?: string | null
  /**
   * Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.
   * Can be used instead of `Symbol` field.
   */
  addressType?: CryptocurrencyAddressType | null
  /** Chain of the required cryptocurrency, e.g. USDT has USDT-ERC20, USDT-TRC20, and USDT-Omni */
  chain?: string | null
  /** Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect */
  mfaCode?: string | null
}

export type BrokerCryptocurrencyTransactionBlockchainMethod =
  | 'transfer'
  | 'swap'
  | 'mint'
  | 'withdraw'
  | 'claimRewards'
  | 'deposit'
  | 'approve'
  | 'forgeToken'
  | 'multicall'
  | 'migrateToken'
  | 'claim'
  | 'openSeaTransfer'
  | 'cancel'
  | 'commit'
  | 'run'
  | 'repay'
  | 'execute'
  | 'stake'
  | 'merge'

export interface BrokerCryptocurrencyTransactionDetailsRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Type of the address of the transferred asset. Can be used instead of the `Symbol` field. */
  addressType?: CryptocurrencyAddressType | null
  /** Transaction Id by the financial institution */
  transactionId?: string | null
  /** Hash of the transaction on the blockchain */
  transactionHash?: string | null
  /** Symbol of the transferred asset. Can be provided instead of the `AddressType` field. */
  symbol?: string | null
}

export interface BrokerCryptocurrencyTransactionNetworkFee {
  /** @format double */
  gasPrice?: number | null
  /** @format double */
  gasUsed?: number | null
  /** @format double */
  amount?: number | null
  symbol?: string | null
}

export type BrokerCryptocurrencyTransactionStatus =
  | 'unknown'
  | 'failed'
  | 'frozen'
  | 'succeeded'
  | 'mfaRequired'
  | 'pending'
  | 'expired'
  | 'canceled'
  | 'waitingForSignature'
  | 'waitingForClearing'
  | 'awaitingApproval'
  | 'awaitingConfirmation'
  | 'awaitingVerification'
  | 'rejected'
  | 'pendingCancel'
  | 'emailVerification'
  | 'deviceConfirmationRequired'
  | 'mfaFailed'
  | 'addressWhitelistRequired'
  | 'secondMfaRequired'
  | 'emailConfirmationApprovalRequired'

export type BrokerCryptocurrencyTransactionType = 'unknown' | 'deposit' | 'withdrawal'

export type BrokerFeature =
  | 'holdings'
  | 'balance'
  | 'orders'
  | 'transfers'
  | 'identity'
  | 'cryptocurrencyDepositAddresses'
  | 'accountNumber'
  | 'paymentMethods'
  | 'conversions'

export interface BrokerFiatBalance {
  /** Account balance currency */
  symbol?: string | null
  /**
   * BuyingPower indicates total amount of money the user can spend for buying stock. Always includes cash and
   * can also include margin
   * @format double
   */
  buyingPower?: number | null
  /**
   * BuyingPower indicates total amount of money the user can spend for buying crypto.
   * @format double
   */
  cryptoBuyingPower?: number | null
  /**
   * Account cash indicates total amount of money
   * @format double
   */
  cash?: number | null
}

export type BrokerOptionDirection =
  | 'unknown'
  | 'buyToOpen'
  | 'buyToClose'
  | 'sellToOpen'
  | 'sellToClose'
  | 'buyToCover'
  | 'sellShort'

export type BrokerOptionType = 'unknown' | 'call' | 'put'

export type BrokerOrderCategory = 'order' | 'trade' | 'ledger' | 'historyAction'

export type BrokerOrderPlaceType =
  | 'unknown'
  | 'market'
  | 'limit'
  | 'stopLoss'
  | 'stopLimit'
  | 'takeProfit'
  | 'netDebit'
  | 'netCredit'
  | 'exercise'

export type BrokerOrderPlaceTypeTrade = 'market' | 'limit' | 'stopLoss'

export type BrokerOrderStatus =
  | 'unknown'
  | 'inProgress'
  | 'cancelled'
  | 'rejected'
  | 'failed'
  | 'success'
  | 'partiallyFilled'
  | 'expired'

export type BrokerOrderTimeInForceType =
  | 'goodTillCanceled'
  | 'immediateOrCancel'
  | 'fillOrKill'
  | 'goodForDay'
  | 'postOnly'
  | 'unknown'

export type BrokerOrderType = 'unknown' | 'buy' | 'sell'

export type BrokerOrderValidationStatus = 'success' | 'failed'

export type BrokerPairTradeTimeInForceType = 'immediateOrCancel' | 'goodTillCanceled' | 'goodTillDate' | 'fillOrKill'

export type BrokerPaymentMethodType = 'card' | 'bankAccount' | 'digitalWallet' | 'unknown'

export interface BrokerPortfolioValueModel {
  /**
   * Total USD value of portfolio.
   * @format double
   */
  readonly totalValue?: number
  /**
   * Total performance in percents based on the cost basis.
   * @format double
   */
  totalPerformance?: number
  /**
   * USD value of all equities in the portfolio.
   * @format double
   */
  equitiesValue?: number
  /**
   * Performance in percents of all equities based on the cost basis.
   * @format double
   */
  equitiesPerformance?: number
  /**
   * USD value of all cryptocurrencies in the portfolio.
   * @format double
   */
  cryptocurrenciesValue?: number
  /**
   * Performance in percents of all cryptocurrencies in the portfolio based on the cost basis.
   * @format double
   */
  cryptocurrenciesPerformance?: number
  /**
   * USD value of all NFTs in the portfolio.
   * @format double
   */
  nftsValue?: number
  /**
   * USD value of all fiat currencies in the portfolio.
   * @format double
   */
  fiatValue?: number
}

export interface BrokerPortfolioValueModelApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: BrokerPortfolioValueModel | null
}

export interface BrokerRefreshTokenRequest {
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** @minLength 1 */
  refreshToken: string
  /**
   * Optional, used when we the refresh token should be refreshed.
   * Currently this flow is supported by TD Ameritrade
   */
  createNewRefreshToken?: boolean | null
  /**
   * Some institutions may require accessToken to be provided as well.
   * It's currently required by WeBull and Vanguard
   */
  accessToken?: string | null
  /** Currently used to update WeBull trade token. */
  tradeToken?: string | null
  /** Optional, currently used by Vanguard if account has enforced MFA enabled. */
  mfaCode?: string | null
  /** Additional metadata */
  metadata?: Record<string, string | null>
}

export type BrokerRequestStatus = 'succeeded' | 'failed' | 'notAuthorized'

export type BrokerResponseStatus = 'unknown' | 'mfaRequired' | 'kycRequired'

export interface BrokerTransactionsListRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Number of records to include in the response.
   *
   * Default: `100`
   *
   * Maximum: `250`
   * @format int32
   */
  count?: number
  /**
   * The cursor to retrieve the next page of transactions.
   * Providing it will cause the response to only return changes after this update.
   * If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
   */
  cursor?: string | null
  /** If this value is provided, result set is filtered to only include transaction with the provided statuses. */
  statuses?: BrokerCryptocurrencyTransactionStatus[] | null
  /** For cryptocurrency address the type of address is required. */
  cryptocurrencyAddressType?: CryptocurrencyAddressType | null
  /**
   * If this value is provided, result set is filtered to only include transactions created after this timestamp
   * @format int64
   */
  from?: number | null
}

export type BrokerType =
  | 'robinhood'
  | 'eTrade'
  | 'alpaca'
  | 'tdAmeritrade'
  | 'weBull'
  | 'stash'
  | 'interactiveBrokers'
  | 'public'
  | 'coinbase'
  | 'kraken'
  | 'coinbasePro'
  | 'cryptoCom'
  | 'openSea'
  | 'binanceUs'
  | 'gemini'
  | 'cryptocurrencyAddress'
  | 'cryptocurrencyWallet'
  | 'okCoin'
  | 'bittrex'
  | 'kuCoin'
  | 'etoro'
  | 'cexIo'
  | 'binanceInternational'
  | 'bitstamp'
  | 'gateIo'
  | 'acorns'
  | 'okx'
  | 'bitFlyer'
  | 'coinlist'
  | 'huobi'
  | 'bitfinex'
  | 'deFiWallet'
  | 'krakenDirect'
  | 'vanguard'
  | 'binanceInternationalDirect'
  | 'bitfinexDirect'
  | 'bybit'
  | 'paxos'
  | 'coinbasePrime'
  | 'btcTurkDirect'
  | 'kuCoinDirect'
  | 'okxOAuth'
  | 'paribuDirect'
  | 'robinhoodConnect'
  | 'blockchainCom'
  | 'bitsoDirect'
  | 'binanceConnect'
  | 'binanceOAuth'
  | 'revolutConnect'
  | 'binancePay'
  | 'bybitDirect'
  | 'paribuOAuth'
  | 'payPalConnect'

export interface CatalogLink {
  /**
   * Url to open Front catalog that should be presented to the end user.
   * @format uri
   */
  url?: string | null
  /**
   * Url to open Front catalog in iFrame that should be presented to the end user.
   * @format uri
   */
  iFrameUrl?: string | null
}

export interface CatalogLinkApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: CatalogLink | null
}

export type ClientType =
  | 'undefined'
  | 'wallet'
  | 'exchange'
  | 'vasp'
  | 'merchant'
  | 'other'
  | 'psp'
  | 'neobank'
  | 'iGaming'
  | 'aggregator'

export interface ConfigureTransferRequest {
  /**
   * The authentication token to send assets from.
   * @minLength 1
   */
  fromAuthToken: string
  /** The type of the integration to send assets from. */
  fromType:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * The authentication token of the target integration. Can be used alternatively to the list of requested address (`toAddresses`).
   * If used, `toType` should also be provided.
   */
  toAuthToken?: string | null
  /** The type of the target integration to send assets to. Used along with the `toAuthToken` alternatively to `toAddresses`. */
  toType?: BrokerType | null
  /**
   * A list of available addresses provided by the API client. The list can contain all supported addresses by the client.
   * Front API validates the addresses and returns the list of supported tokens and networks as the result of the operation.
   */
  toAddresses?: TransferToAddress[] | null
  /** If provided, Front API returns only networks that support transferring of this symbol. */
  symbol?: string | null
  /**
   * If provided, Front API configures the response to only return holdings with enough amount of this crypto for the transfer
   * @format double
   */
  amount?: number | null
  /**
   * If provided, Front API configures the response to only contain holdings with enough value (converted to fiat) for the transfer.
   * @format double
   */
  amountInFiat?: number | null
  /** Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `USD`. */
  fiatCurrency?: string | null
  /**
   * If provided, from API configures the response to include the requested network only.
   * @format uuid
   */
  networkId?: string | null
  /** Specifies if all the fees are included in the amount to transfer. */
  isInclusiveFeeEnabled?: boolean
}

export interface ConfigureTransferResponse {
  /** Status of the operation. */
  status?:
    | 'succeeded'
    | 'failed'
    | 'validationFailed'
    | 'notAuthorizedTo'
    | 'notAuthorizedFrom'
    | 'kycRequired'
    | 'fromIntegrationNotSupported'
    | 'toIntegrationNotSupported'
  /** Error message, if the operation did not complete successfully. */
  errorMessage?: string | null
  /** List of holdings on the source account. */
  holdings?: ConfigureTransferResultHolding[] | null
  /**
   * Amount in USD to transfer.
   * @format double
   */
  amountInFiat?: number | null
  /** Used fiat currency. */
  fiatCurrency?: string | null
  /**
   * Minimum transfer amount in fiat.
   * @format double
   */
  minimumTransferAmountInFiat?: number | null
  /**
   * Maximum transfer amount in fiat
   * @format double
   */
  maximumTransferAmountInFiat?: number | null
  /** Supported fiat currencies for this transfer */
  supportedFiatCurrencies?: string[] | null
  transferBalanceFundingAvailability?: TransferBalanceFundingAvailabilityBase | null
}

export interface ConfigureTransferResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: ConfigureTransferResponse | null
}

export interface ConfigureTransferResultHolding {
  /** The symbol of the digital asset on the source account. */
  symbol?: string | null
  /**
   * The available balance of the digital asset.
   * @format double
   */
  availableBalance?: number
  /**
   * The available balance of the digital asset, converted to fiat currency.
   * @format double
   */
  availableBalanceInFiat?: number
  /** Specifies if the asset is eligible for a transfer. */
  eligibleForTransfer?: boolean
  /** Supported networks. */
  networks?: ConfigureTransferResultNetwork[] | null
  /** The reason indicating why the transfer of the current asset cannot be performed. */
  ineligibilityReason?: HoldingTransferIneligibilityReason | null
  /**
   * Indicates that the asset is not eligible for a transfer with the current holding balance,
   * but can be made eligible after funding the balance using the cryptocurrency balance funding feature.
   */
  eligibleForTransferWithFunding?: boolean
  /**
   * Logo url for holding.
   * @format uri
   */
  logoUrl?: string | null
}

export interface ConfigureTransferResultNetwork {
  /** The name of the network. */
  name?: string | null
  /**
   * The Id of the network in Front system.
   * @format uuid
   */
  id?: string
  /**
   * Then minimum amount that can be withdrawn using this network.
   * @format double
   */
  minimumAmount?: number | null
  /**
   * The maximum amount that can be withdrawn using this network.
   * @format double
   */
  maximumAmount?: number | null
  /**
   * Total estimated transfer fee converted to fiat. Can consist of the fee taken by the financial institution and the
   * gas fee.
   * @format double
   */
  totalEstimatedTransferFeeInFiat?: number | null
  /**
   * The minimum amount that can be withdrawn using this network, converted to fiat currency.
   * @format double
   */
  minimumAmountInFiat?: number | null
  /**
   * The maximum amount that can be withdrawn using this network, converted to fiat currency.
   * @format double
   */
  maximumAmountInFiat?: number | null
  /**
   * The gas fee that is estimated to be taken by the network. Depending on the integration, the network gas fee might be
   * covered by the `InstitutionTransferFee`.
   */
  estimatedNetworkGasFee?: TransferFee | null
  /**
   * The fee that is taken by the institution. Depending on the institution, can cover the gas fee. Some institutions do not
   * take the transfer fee and only network fee is used for the transfer.
   */
  institutionTransferFee?: TransferFee | null
  /** Specifies if the asset is eligible for a transfer over the current network. */
  eligibleForTransfer?: boolean
  /** The reason indicating why the transfer cannot be performed over this network. */
  ineligibilityReason?: NetworkTransferIneligibilityReason | null
  eligibleForTransferWithFunding?: boolean
  /** The designated destination for sending the asset. */
  toAddress?: string | null
  /**
   * Token's amount to transfer specified by the client.
   * @format double
   */
  transferAmount?: number | null
  /**
   * The minimum amount of cryptocurrency that is required to be present in the account to perform the transfer.
   * Unlike `minimum` field that indicates the minimum amount that can generally be transferred, this field indicates the minimum
   * that can be transferred given the current transfer configuration values, such as `amountInFiat` and `clientFee`.
   * @format double
   */
  minimumRequiredForTransferAmount?: number | null
  /**
   * Logo url for network.
   * @format uri
   */
  logoUrl?: string | null
}

export type ConfigureTransferStatus =
  | 'succeeded'
  | 'failed'
  | 'validationFailed'
  | 'notAuthorizedTo'
  | 'notAuthorizedFrom'
  | 'kycRequired'
  | 'fromIntegrationNotSupported'
  | 'toIntegrationNotSupported'

export interface CountryInfo {
  countryCode?: string | null
  countryNumber?: string | null
  description?: string | null
}

export type CryptocurrencyAddressType =
  | 'ethAddress'
  | 'btcAddress'
  | 'ltcAddress'
  | 'solAddress'
  | 'algoAddress'
  | 'celoAddress'
  | 'cardanoAddress'
  | 'polygonAddress'
  | 'bnbAddress'
  | 'elrondAddress'
  | 'neoAddress'
  | 'xrpAddress'
  | 'flowAddress'
  | 'harmonyOneAddress'
  | 'tronAddress'
  | 'dogeAddress'
  | 'opAddress'

export type CryptocurrencyFundingOptionType =
  | 'existingCryptocurrencyBalance'
  | 'buyingPowerPurchase'
  | 'paymentMethodDepositUsage'
  | 'cryptocurrencyConversion'
  | 'stableCoinNoFeeConversion'
  | 'cryptocurrencyBuyingPowerConversion'
  | 'cryptocurrencyMultiStepConversion'

export interface DeFiWalletHealthStatusInfo {
  /** @format uuid */
  id?: string
  name?: string | null
}

/** Verifications data. */
export interface DeFiWalletVerification {
  /** User identifier. */
  userId?: string | null
  /** Wallet address. */
  address?: string | null
  /** Wallet Xpub key for Bitcon wallets. */
  xPubKey?: string | null
  /** Wallet network type. */
  networkType?:
    | 'unknown'
    | 'evm'
    | 'solana'
    | 'bitcoin'
    | 'cardano'
    | 'tron'
    | 'avalancheX'
    | 'tezos'
    | 'dogecoin'
    | 'ripple'
    | 'stellar'
    | 'litecoin'
    | 'sui'
    | 'aptos'
    | 'tvm'
  /** Verification method. */
  verificationMethod?: 'signedMessage'
  /** Original message. */
  message?: string | null
  /** Message signature. */
  signedMessageHash?: string | null
  /**
   * Verification created timestamp.
   * @format int64
   */
  timestamp?: number
}

/** Verifications response. */
export interface DeFiWalletVerificationResponse {
  /** List of found verifications. */
  verifications?: DeFiWalletVerification[] | null
}

export interface DeFiWalletVerificationResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  /** Verifications response. */
  content?: DeFiWalletVerificationResponse | null
}

/** Exchange account info request. */
export interface ExchangeAccountInfoRequest {
  /** Auth token that allows connecting to the target institution. */
  authToken?: string | null
  /**
   * The Id which uniquely identifies the integration.
   * @format uuid
   */
  integrationId?: string
  /** Account information to return. */
  accountInfo?: AccountInfoType[] | null
}

export type ExecuteTransferMfaType = 'unspecified' | 'phone' | 'email' | 'totp' | 'face' | 'tradingPin' | 'mobile'

export interface ExecuteTransferRequest {
  /**
   * The authentication token to send the asset from.
   * @minLength 1
   */
  fromAuthToken: string
  /** The type of the integration to send the asset from. */
  fromType:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Id of the Preview of the transfer.
   * @format uuid
   */
  previewId: string
  /** Multi-factor auth code that should be provided if the status of the transfer was `MfaRequired`. */
  mfaCode?: string | null
  /** When user is unable to provide the primary Mfa this should be passed in to use fallback Mfa. */
  tryAnotherMfa?: boolean
  challengeId?: string | null
}

export interface ExecuteTransferResponse {
  /** The status of the transfer. */
  status?:
    | 'succeeded'
    | 'inProgress'
    | 'failed'
    | 'mfaRequired'
    | 'emailConfirmationRequired'
    | 'deviceConfirmationRequired'
    | 'mfaFailed'
    | 'addressWhitelistRequired'
    | 'secondMfaRequired'
    | 'deFiWalletConfirmationRequired'
    | 'emailConfirmationApprovalRequired'
  /** The type of the MFA when the status is `MfaRequired`. */
  mfaType?: ExecuteTransferMfaType | null
  /** The type of the MFA when the status is `MfaRequired`. */
  verificationSteps?: ExecuteTransferMfaType[] | null
  /**
   * The transaction number for Travel rule required clients (optional, depends on an integration).
   * @format int32
   */
  travelRuleTransactionId?: number | null
  qrCode?: string | null
  qrCodeLink?: string | null
  /** Error message, if the operation did not complete successfully. */
  errorMessage?: string | null
  /** Result of the transfer initiation. */
  executeTransferResult?: ExecuteTransferResultResponse | null
  fallbackMfaAvailable?: boolean
  challengeId?: string | null
}

export interface ExecuteTransferResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: ExecuteTransferResponse | null
}

export interface ExecuteTransferResultResponse {
  /** The Id of the transfer by the integration. */
  transferId?: string | null
  /** The current status of the transfer. */
  status?:
    | 'unknown'
    | 'failed'
    | 'frozen'
    | 'succeeded'
    | 'mfaRequired'
    | 'pending'
    | 'expired'
    | 'canceled'
    | 'waitingForSignature'
    | 'waitingForClearing'
    | 'awaitingApproval'
    | 'awaitingConfirmation'
    | 'awaitingVerification'
    | 'rejected'
    | 'pendingCancel'
    | 'emailVerification'
    | 'deviceConfirmationRequired'
    | 'mfaFailed'
    | 'addressWhitelistRequired'
    | 'secondMfaRequired'
    | 'emailConfirmationApprovalRequired'
  /** Details of the current status of the transfer, as provided by the integration. */
  statusDetails?: string | null
  /** The address of the source account or wallet. */
  fromAddress?: string | null
  /** The address of the target account or wallet. */
  toAddress?: string | null
  /** Transferred symbol. */
  symbol?: string | null
  /** The name of the used network. */
  networkName?: string | null
  /**
   * The Id of the used network in Front system.
   * @format uuid
   */
  networkId?: string
  /** The hash of the blockchain transaction. */
  hash?: string | null
  /**
   * The transferred amount, in the symbol of the transfer.
   * @format double
   */
  amount?: number
  /**
   * The transferred amount, converted to the fiat currency.
   * @format double
   */
  amountInFiat?: number
  /**
   * Total amount of the transfer including all fees, converted to fiat.
   * @format double
   */
  totalAmountInFiat?: number
  /**
   * Current number of network confirmations.
   * @format int64
   */
  completedConfirmations?: number | null
  /** The fee that was taken by the institution. */
  institutionTransferFee?: TransferFee | null
  /**
   * The gas fee that was taken by the network. Depending on the integration, the network gas fee might be
   * covered by the `InstitutionTransferFee`.
   */
  networkGasFee?: TransferFee | null
  /** Details of the allocated Smart Contract in case of 'Deposit' type transfers. */
  smartContract?: SmartContractTransferAllocation | null
}

export type ExecuteTransferStatus =
  | 'succeeded'
  | 'inProgress'
  | 'failed'
  | 'mfaRequired'
  | 'emailConfirmationRequired'
  | 'deviceConfirmationRequired'
  | 'mfaFailed'
  | 'addressWhitelistRequired'
  | 'secondMfaRequired'
  | 'deFiWalletConfirmationRequired'
  | 'emailConfirmationApprovalRequired'

export type FailureReason =
  | 'notSupportedOnIntegration'
  | 'notSupportedOnNetwork'
  | 'invalidAddressFormat'
  | 'notSupportedOnToken'

export type FinancialInstitutionIntegrationType =
  | 'brokerage'
  | 'bank'
  | 'exchange'
  | 'wallet'
  | 'address'
  | 'nftMarketplace'
  | 'deFiWallet'

export interface GetLinkTokenRequest {
  /**
   * A unique Id representing the end user. Typically this will be a user Id from the
   * client application. Personally identifiable information, such as an email address or phone number,
   * should not be used. 50 characters length maximum.
   * @minLength 1
   * @maxLength 50
   */
  userId: string
  /**
   * Type of integration to redirect to. Will redirect to catalog if not provided.
   * Not supported types: DeFiWallet, CryptocurrencyAddress, CryptocurrencyWallet.
   * @deprecated
   */
  brokerType?: BrokerType | null
  /**
   * The final screen of Link allows users to continue back to your app or Link another account.
   * If this param is present then this button will be hidden.
   */
  restrictMultipleAccounts?: boolean
  /** Encapsulates transaction-related parameters, including destination addresses and the amount to transfer in fiat currency. */
  transferOptions?: LinkTokenTransferOptions | null
  /**
   * A unique identifier representing a specific integration obtained from the list of available integrations.
   * @format uuid
   */
  integrationId?: string | null
  /**
   * For direct integrations that also support API keys, Link presents the user with the option to generate an API key for seamless access.
   * If this param is true, this feature will be disabled.
   */
  disableApiKeyGeneration?: boolean
  /** Encapsulates verify DeFi wallet parameters. */
  verifyWalletOptions?: VerifyWalletOptions | null
  /**
   * Sub Client ID, for B2B2B clients to tailor Link experience for their clients.
   * @format uuid
   */
  subClientId?: string | null
}

export interface GoodsDetails {
  /** The type of the goods for the order (01: Tangible Goods, 02: Virtual Goods). */
  goodsType?: string | null
  /** The category of goods (e.g., Electronics, Food). */
  goodsCategory?: string | null
  /** A unique reference ID to identify the goods. */
  referenceGoodsId?: string | null
  /** The name of the goods. */
  goodsName?: string | null
  /** Additional details about the goods (optional). */
  goodsDetail?: string | null
}

export type HoldingTransferIneligibilityReason =
  | 'noEligibleNetworks'
  | 'symbolDoesNotMatch'
  | 'notSupportedForTransferByTarget'
  | 'notSupportedForTransferBySource'
  | 'eligibleWithFunding'
  | 'amountNotSufficient'
  | 'noPrice'

export interface HoldingsModel {
  /** Status of the request to the institution's API */
  status?: 'succeeded' | 'failed' | 'notAuthorized'
  /** Error message specifying the problem */
  errorMessage?: string | null
  /** User-friendly error message, optimized to be shown to the end user */
  displayMessage?: string | null
  /** The equity positions Front could not recognize */
  notSupportedEquityPositions?: Position[] | null
  /** The cryptocurrency positions Front could not recognize */
  notSupportedCryptocurrencyPositions?: Position[] | null
  /** NFT holdings on the account */
  nftPositions?: B2BNftPosition[] | null
  /** Option holdings on the account */
  optionPositions?: B2BOptionPosition[] | null
  /** Type of the institution */
  type?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** External institution's account id (returned by the institution) */
  accountId?: string | null
  /** Friendly name of the connected institution */
  institutionName?: string | null
  /** Name of the account as returned from the institution */
  accountName?: string | null
  /** Equity holdings, such as stocks and ETFs */
  equityPositions?: PositionWithMarketValue[] | null
  /** Cryptocurrency holdings on the account */
  cryptocurrencyPositions?: PositionWithMarketValue[] | null
}

export interface HoldingsModelApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: HoldingsModel | null
}

export interface HoldingsRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  includeMarketValue?: boolean
}

export interface InitializeTransfersForLinkRequest {
  /**
   * The list of destination addresses with corresponding networks are asset symbols that
   * can be used to initiate incoming transfers.
   */
  toAddresses?: TransferToAddressWithAmount[] | null
  /**
   * Amount in USD to transfer. If not provided users can specify amount by themselves.
   * @format double
   */
  amountInFiat?: number | null
  /**
   * Transaction ID Provided by client to track transaction in future calls
   * @minLength 0
   * @maxLength 128
   */
  transactionId?: string | null
  /**
   * A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments to your company.
   * This will override any default fee entered in your Mesh dashboard for an individual transaction.
   * Please note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),
   * and not for Deposits (when the transfer destination is an address owned by the end user).
   * If used for Deposits, it will increase the size of the user's Deposit by the fee amount,
   * but will incorrectly show to the user as a fee.
   * @format double
   * @min 0
   * @max 1
   */
  clientFee?: number
  /**
   * Deposit (default): The user is transferring crypto to a wallet they own on your platform.
   * Payment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.
   * Onramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.
   */
  transferType?: TransferTypeEnum | null
  /**
   * Transaction description. (Binance Pay)
   * @minLength 0
   * @maxLength 256
   */
  description?: string | null
  /** Goods details for the transaction. (Binance Pay) */
  goodsDetails?: GoodsDetails[] | null
}

/** Integreation logos. */
export interface IntegrationLogo {
  /** Light logo url. */
  logoLightUrl?: string | null
  /** Dark logo url. */
  logoDarkUrl?: string | null
  /** White logo url. */
  logoWhiteUrl?: string | null
  /** Black logo url. */
  logoBlackUrl?: string | null
  /** Colored logo url. */
  logoColorUrl?: string | null
  /** White icon url. */
  iconLightUrl?: string | null
  /** Light icon url. */
  iconDarkUrl?: string | null
  /** Dark icon url. */
  iconWhiteUrl?: string | null
  /** Balck icon url. */
  iconBlackUrl?: string | null
  /** Colored logo url. */
  iconColorUrl?: string | null
  /** Base64 PNG logo. */
  base64Logo?: string | null
}

/** Integration model. */
export interface IntegrationModel {
  /**
   * Integration unique identifier.
   * @format uuid
   */
  id?: string
  /** Integration name. */
  name?: string | null
  /** Integration type. */
  type?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** DeFi wallet provider identifier. */
  deFiWalletProviderId?: string | null
  /** Integration categories. */
  categories?: FinancialInstitutionIntegrationType[] | null
  /** Style object. */
  style?: IntegrationStyle | null
  /** Logo object. */
  logo?: IntegrationLogo | null
  /** Forgot Password Link. */
  forgotPasswordLink?: string | null
  /** Indicates if crypto transfers supported by integration. */
  cryptoTransfersSupported?: boolean
}

export interface IntegrationNetwork {
  /** @format uuid */
  networkId?: string
  netwokName?: string | null
  innerNetworkId?: string | null
  networkLogo?: string | null
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
}

export interface IntegrationNetworkResponse {
  integrations?: IntegrationNetworksModelResponse[] | null
}

export interface IntegrationNetworkResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: IntegrationNetworkResponse | null
}

export interface IntegrationNetworksModelResponse {
  /** Type of the integration. */
  type?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** The list of supported networks and corresponding tokens for the integration. */
  networks?: NetworkResponse[] | null
  /** Specifies if the integration supports outgoing transfers. */
  supportsOutgoingTransfers?: boolean
  /** Specifies if the integration supports incoming transfers. */
  supportsIncomingTransfers?: boolean
}

/** Integration style */
export interface IntegrationStyle {
  /** Field Active Light Hex Color */
  fieldActiveLight?: string | null
  /** Button Primary Light Hex Color */
  buttonPrimaryLight?: string | null
  /** Button Hover Light Hex Color */
  buttonHoverLight?: string | null
  /** Button Text Light Hex Color */
  buttonTextLight?: string | null
  /** Button Text Hover Light Hex Color */
  buttonTextHoverLight?: string | null
  /** Field Active Dark Hex Color */
  fieldActiveDark?: string | null
  /** Button Primary Dark Hex Color */
  buttonPrimaryDark?: string | null
  /** Button Hover Dark Hex Color */
  buttonHoverDark?: string | null
  /** Button Text Dark Hex Color */
  buttonTextDark?: string | null
  /** Button Text Hover Dark Hex Color */
  buttonTextHoverDark?: string | null
}

/** Integration response. */
export interface IntegrationsResponse {
  /** Integrations list. */
  items?: IntegrationModel[] | null
}

export interface IntegrationsResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  /** Integration response. */
  content?: IntegrationsResponse | null
}

export interface LinkTokenModel {
  linkToken?: string | null
}

export interface LinkTokenModelApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: LinkTokenModel | null
}

export interface LinkTokenTransferOptions {
  /**
   * The list of destination addresses with corresponding networks are asset symbols that
   * can be used to initiate incoming transfers. If this parameter is present, the Link
   * session will continue to transfer flow after connecting the origin account.
   */
  toAddresses?: TransferToAddressWithAmount[] | null
  /**
   * Amount in USD to transfer. If not provided users can specify amount by themselves.
   * @format double
   */
  amountInFiat?: number | null
  /**
   * Transaction ID Provided by client to track transaction in future calls
   * @minLength 0
   * @maxLength 128
   */
  transactionId?: string | null
  /**
   * A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments to your company.
   * This will override any default fee entered in your Mesh dashboard for an individual transaction.
   * Please note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),
   * and not for Deposits (when the transfer destination is an address owned by the end user).
   * If used for Deposits, it will increase the size of the user's Deposit by the fee amount,
   * but will incorrectly show to the user as a fee.
   * @format double
   * @min 0
   * @max 1
   */
  clientFee?: number | null
  /**
   * Deposit: The user is transferring crypto to a wallet they own on your platform.
   * Payment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.
   * Onramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.
   */
  transferType?: TransferTypeEnum | null
  /**
   * Specifies the permitted options to use the end user's available buying power
   * and/or payment methods to supplement the cryptocurrency balance if it is insufficient
   * for the transfer.
   */
  fundingOptions?: TransferCryptocurrencyFundingOptions | null
  /** Specifies if all the fees are included in the amount to transfer. */
  isInclusiveFeeEnabled?: boolean
  /**
   * Transaction description. (Binance Pay)
   * @minLength 0
   * @maxLength 256
   */
  description?: string | null
  /** Goods details for the transaction. (Binance Pay) */
  goodsDetails?: GoodsDetails[] | null
}

export interface ManagedBrokerCryptocurrencyDepositAddressRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Symbol of the required cryptocurrency, e.g. ETH or BTC.
   * Can be used instead of the `AddressType` field.
   */
  symbol?: string | null
  /**
   * Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.
   * Can be used instead of `Symbol` field.
   */
  addressType?: CryptocurrencyAddressType | null
  /**
   * Specifies which the network to use to obtain the deposit address of the `Symbol` asset.
   * @format uuid
   */
  networkId?: string
  /** Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect */
  mfaCode?: string | null
}

export type MfaScheme = 'mfaCode' | 'challenge' | 'deviceConfirmation' | 'securityQuestion'

export type MfaType =
  | 'phone'
  | 'email'
  | 'totp'
  | 'phoneAndEmail'
  | 'requireNextSecurityQuestion'
  | 'readEmail'
  | 'face'
  | 'tradingPin'
  | 'qrCode'
  | 'password'
  | 'roaming'
  | 'mobile'

export interface NetworkModelResponse {
  networks?: NetworkResponseWithIntegrations[] | null
}

export interface NetworkModelResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: NetworkModelResponse | null
}

/** Crypto network. */
export interface NetworkResponse {
  /**
   * The Id of the network in Mesh system. Should be used to initiate transfers.
   * @format uuid
   */
  id?: string
  /** The name if the network. */
  name?: string | null
  /** The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137. */
  chainId?: string | null
  /** Network logo URL. */
  logoUrl?: string | null
  /** The list of tokens that are currently supported to be transferred using the network. */
  supportedTokens?: string[] | null
  /** The symbol of the network's native cryptocurrency. */
  nativeSymbol?: string | null
}

/** Crypto network. */
export interface NetworkResponseBase {
  /**
   * The Id of the network in Mesh system. Should be used to initiate transfers.
   * @format uuid
   */
  id?: string
  /** The name if the network. */
  name?: string | null
  /** The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137. */
  chainId?: string | null
  /** Network logo URL. */
  logoUrl?: string | null
}

export interface NetworkResponseToken {
  symbol?: string | null
  logoUrl?: string | null
}

/** Crypto network. */
export interface NetworkResponseWithIntegrations {
  /**
   * The Id of the network in Mesh system. Should be used to initiate transfers.
   * @format uuid
   */
  id?: string
  /** The name if the network. */
  name?: string | null
  /** The Inner id of the chain, used for reference. For example, Polygon's (MATIC) chain Id is 137. */
  chainId?: string | null
  /** Network logo URL. */
  logoUrl?: string | null
  /** The list of tokens that are currently supported to be transferred using the network. */
  supportedTokens?: string[] | null
  /** The symbol of the network's native cryptocurrency. */
  nativeSymbol?: string | null
  /** Network type. */
  networkType?:
    | 'unknown'
    | 'evm'
    | 'solana'
    | 'bitcoin'
    | 'cardano'
    | 'tron'
    | 'avalancheX'
    | 'tezos'
    | 'dogecoin'
    | 'ripple'
    | 'stellar'
    | 'litecoin'
    | 'sui'
    | 'aptos'
    | 'tvm'
  /** The list of tokens that are currently supported to be transferred using the network. */
  tokens?: NetworkResponseToken[] | null
  /** The list of types of integrations that are currently supported to perform transfers over the network. */
  supportedBrokerTypes?: BrokerType[] | null
}

export type NetworkTransferIneligibilityReason =
  | 'amountNotSufficient'
  | 'gasFeeAssetBalanceNotEnough'
  | 'noTargetNetworkFound'
  | 'refusedByInstitution'
  | 'eligibleWithFunding'
  | 'balanceBelowRequestedAmount'
  | 'requestedAmountBelowMinimum'
  | 'balanceBelowMinimum'
  | 'requestedAmountBelowFees'
  | 'requestedAmountBelowClientMinimum'
  | 'requestedAmountAboveClientMaximum'
  | 'noPrice'

export type NetworkType =
  | 'unknown'
  | 'evm'
  | 'solana'
  | 'bitcoin'
  | 'cardano'
  | 'tron'
  | 'avalancheX'
  | 'tezos'
  | 'dogecoin'
  | 'ripple'
  | 'stellar'
  | 'litecoin'
  | 'sui'
  | 'aptos'
  | 'tvm'

export type NftBlockchain = 'ethereum' | 'polygon' | 'klaytn'

export interface NftOrder {
  orderSide?: 'buy' | 'sell'
  symbol?: string | null
  /** @format double */
  price?: number
  /** @format double */
  priceUsd?: number | null
  /** @format double */
  amount?: number
  /** @format int64 */
  createdTimestamp?: number | null
  /** @format int64 */
  updatedTimestamp?: number | null
  symbolLogo?: string | null
}

export type NftOrderSide = 'buy' | 'sell'

export interface NftPositionWithMarketValues {
  /** @format double */
  amount?: number
  /** @format double */
  costBasis?: number | null
  contractAddress?: string | null
  paymentTokenSymbol?: string | null
  name?: string | null
  description?: string | null
  imageUrl?: string | null
  imageOriginalUrl?: string | null
  animationUrl?: string | null
  backgroundColor?: string | null
  marketplaceId?: string | null
  tokenId?: string | null
  /** @format int64 */
  numberOfSales?: number | null
  contractType?: string | null
  contractName?: string | null
  contractSchemaName?: string | null
  contractSymbol?: string | null
  contractDescription?: string | null
  marketplacePermalink?: string | null
  contractExternalLink?: string | null
  creatorAddress?: string | null
  currentOffer?: NftOrder | null
  lastSale?: NftOrder | null
  blockchain?: 'ethereum' | 'polygon' | 'klaytn'
  addressExplorerLink?: string | null
  twitterUsername?: string | null
  /**
   * Amount of NFTs multiplied by NFT value
   * @format double
   */
  marketValue?: number | null
  /**
   * What percentage of total portfolio value is taken by this NFT
   * @format double
   */
  portfolioPercentage?: number | null
}

export interface PortfolioBrokerBaseRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```ETrade```
   * ```Alpaca```
   * ```WeBull```
   * ```Stash```
   * ```InteractiveBrokers```
   * ```Public```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```OpenSea```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```Etoro```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Acorns```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```Vanguard```
   * ```BinanceInternationalDirect```
   * ```BitfinexDirect```
   * ```Bybit```
   * ```Paxos```
   * ```CoinbasePrime```
   * ```BtcTurkDirect```
   * ```KuCoinDirect```
   * ```OkxOAuth```
   * ```ParibuDirect```
   * ```RobinhoodConnect```
   * ```BlockchainCom```
   * ```BitsoDirect```
   * ```BinanceOAuth```
   * ```BybitDirect```
   * ```ParibuOAuth```
   * ```DeFiWallet```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
}

export interface PortfolioFiatBalance {
  /** Balance currency */
  symbol?: string | null
  /**
   * Amount of money in a specific currency from all brokers
   * @format double
   */
  cash?: number | null
  /**
   * BuyingPower from all brokers, it indicates total amount of money the user can spend on buying stock.
   * Always includes cash and can also include margin
   * @format double
   */
  buyingPower?: number | null
}

export interface PortfolioHoldingsRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```ETrade```
   * ```Alpaca```
   * ```WeBull```
   * ```Stash```
   * ```InteractiveBrokers```
   * ```Public```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```OpenSea```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```Etoro```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Acorns```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```Vanguard```
   * ```BinanceInternationalDirect```
   * ```BitfinexDirect```
   * ```Bybit```
   * ```Paxos```
   * ```CoinbasePrime```
   * ```BtcTurkDirect```
   * ```KuCoinDirect```
   * ```OkxOAuth```
   * ```ParibuDirect```
   * ```RobinhoodConnect```
   * ```BlockchainCom```
   * ```BitsoDirect```
   * ```BinanceOAuth```
   * ```BybitDirect```
   * ```ParibuOAuth```
   * ```DeFiWallet```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  includeMarketValue?: boolean
}

export interface Position {
  /** Name of the asset */
  name?: string | null
  /** Symbol of the asset */
  symbol?: string | null
  /**
   * Amount of the asset
   * @format double
   */
  amount?: number
  /**
   * The total original value (or purchase price) of the asset
   * @format double
   */
  costBasis?: number | null
}

export interface PositionWithMarketValue {
  /** Name of the asset */
  name?: string | null
  /** Symbol of the asset */
  symbol?: string | null
  /**
   * Amount of the asset
   * @format double
   */
  amount?: number
  /**
   * The total original value (or purchase price) of the asset
   * @format double
   */
  costBasis?: number | null
  /**
   * Market value of the asset: amount of asset multiplied by last asset value.
   * @format double
   */
  marketValue?: number | null
  /**
   * Current last price of the asset.
   * @format double
   */
  lastPrice?: number | null
}

export interface PositionWithReturn {
  /** Name of the asset */
  name?: string | null
  /** Symbol of the asset */
  symbol?: string | null
  /**
   * Amount of the asset
   * @format double
   */
  amount?: number
  /**
   * The total original value (or purchase price) of the asset
   * @format double
   */
  costBasis?: number | null
  /**
   * Market value of the asset: amount of asset multiplied by last asset value.
   * @format double
   */
  marketValue?: number | null
  /**
   * Current last price of the asset.
   * @format double
   */
  lastPrice?: number | null
  /**
   * What percentage of total portfolio value is taken by this asset.
   * @format double
   */
  portfolioPercentage?: number | null
  /**
   * Total return of investment of this asset. Can be negative or null. Based on the cost basis of the asset, cost basis
   * is not available by some of integrations.
   * @format double
   */
  totalReturn?: number | null
  /**
   * Percent of return of investment for this asset. Can be negative or null.
   * @format double
   */
  returnPercentage?: number | null
  /** Company name of the relative asset/ */
  companyName?: string | null
  /**
   * Total daily return of investment for this asset. Can be negative.
   * @format double
   */
  totalDailyReturn?: number | null
  /**
   * Daily percent of return of investment for this asset. Can be negative.
   * @format double
   */
  dailyReturnPercentage?: number | null
}

export interface PreviewTransferRequest {
  /**
   * The authentication token to send the asset from.
   * @minLength 1
   */
  fromAuthToken: string
  /** The type of the integration to send the asset from. */
  fromType:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * The authentication token of the target integration. Can be used alternatively to the address in the `ToAddress` field.
   * If used, `toType` should also be provided.
   */
  toAuthToken?: string | null
  /** The type of the target integration to send assets to. Used along with the `toAuthToken` alternatively to `ToAddress`. */
  toType?: BrokerType | null
  /**
   * The network to send the asset over.
   * @format uuid
   */
  networkId?: string
  /** The symbol of the digital asset to send. */
  symbol?: string | null
  /** The target address to send the asset to. */
  toAddress?: string | null
  /** Secondary address identifier for coins like XRP,XMR etc. */
  addressTag?: string | null
  /**
   * The amount to send, in crypto.
   * @format double
   */
  amount?: number | null
  /**
   * The amount to send, in fiat currency. Can be used alternatively to `Amount`.
   * @format double
   */
  amountInFiat?: number | null
  /** Fiat currency that is to get corresponding converted fiat values of transfer and fee amounts. If not provided, defaults to `USD`. */
  fiatCurrency?: string | null
  /**
   * Transaction ID Provided by client to track transaction in future calls.
   * @minLength 0
   * @maxLength 128
   */
  transactionId?: string | null
  /** Specifies if all the fees are included in the amount to transfer. */
  isInclusiveFeeEnabled?: boolean
}

export interface PreviewTransferResponse {
  /** The status of the operation. */
  status?: 'succeeded' | 'failed' | 'requiresFunding'
  /** Error message, if the operation did not complete successfully. */
  errorMessage?: string | null
  /** Result of the preview. */
  previewResult?: PreviewTransferResult | null
  transferBalanceFundingAvailability?: TransferBalanceFundingAvailability | null
  /** For instance if not enough assets in Spot account, and we can fill it from Funding account */
  transferFromAnotherAccountAvailabilityInfo?: TransferFromAnotherAccountAvailabilityInfo | null
}

export interface PreviewTransferResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: PreviewTransferResponse | null
}

export interface PreviewTransferResult {
  /**
   * The Id of the preview of the transfer. Should be used to commit the transfer using `Execute` endpoint.
   * @format uuid
   */
  previewId?: string
  /**
   * The period of time in seconds during which the transfer can be committed.
   * @format int32
   */
  previewExpiresIn?: number
  /** Obtained address that will be used to send the transfer. Not guaranteed to be returned by some of integrations. */
  fromAddress?: string | null
  /** The target address to send the asset to. */
  toAddress?: string | null
  /** Secondary address identifier for coins like XRP, XMR etc. */
  addressTag?: string | null
  /** Symbol of the asset to be sent. */
  symbol?: string | null
  /**
   * Amount in symbol. If the transfer was requested using `AmounInFiat` field, this field represents the exact amount
   * of the asset that will be transferred.
   * @format double
   */
  amount?: number
  /**
   * Transfer amount in fiat. If the transfer was requested in crypto amount using the `Amount` field,
   * this field contains the corresponding converted to fiat value.
   * @format double
   */
  amountInFiat?: number
  /**
   * Total estimated amount of the transfer including all fees, in cryptocurrency.
   * @format double
   */
  totalEstimatedAmount?: number
  /**
   * Total estimated amount of the transfer including all fees, converted to fiat.
   * @format double
   */
  totalEstimatedAmountInFiat?: number
  /**
   * Id of the network in Front system.
   * @format uuid
   */
  networkId?: string
  /** Name of the network in Front system. */
  networkName?: string | null
  /** Blockchain address of the transferred token's contract */
  contractAddress?: string | null
  /**
   * The fee that is taken by the institution. Depending on the institution, can cover the gas fee. Some institutions do not
   * take the transfer fee and only network fee is used for the transfer.
   */
  institutionTransferFee?: TransferFee | null
  /**
   * The gas fee that is estimated to be taken by the network. Depending on the integration, the network gas fee might be
   * covered by the `InstitutionTransferFee`.
   */
  estimatedNetworkGasFee?: TransferFee | null
  /**
   * Number of decimal places used to represent the token's smallest unit
   * @format int32
   */
  decimalPlaces?: number | null
  /**
   * The price of the cryptocurrency asset in the fiat currency.
   * @format double
   */
  unitPrice?: number
  /**
   * Transaction id provided by the client
   * @minLength 0
   * @maxLength 128
   */
  clientTransactionId?: string | null
  /**
   * A percentage fee (input as a ratio, eg. 0.02500 = 2.500%) added onto your users' gross payments.
   * This will override any default fee entered in your Mesh dashboard for an individual transaction.
   * Please note: this fee should only be used for Payments (when the transfer destination is an address owned by your company),
   * and not for Deposits (when the transfer destination is an address owned by the end user).
   * If used for Deposits, it will increase the size of the user's Deposit by the fee amount,
   * but will incorrectly show to the user as a fee.
   * @format double
   * @min 0
   * @max 1
   */
  clientFee?: number | null
  /** The client fee that is estimated to be added to the total estimated transfer amount, based on the user's requested transfer amount and client fee percentage. */
  customClientFee?: TransferFee | null
  processingFeeRetainMethod?: ProcessingFeeRetainMethod | null
  /**
   * Deposit: The user is transferring crypto to a wallet they own on your platform.
   * Payment: The user is transferring crypto to a wallet your company owns in exchange for receiving a good or service.
   * Onramp: The user is using balances and linked payment methods in an exchange account to fund the purchase of crypto in their wallet on your platform.
   */
  transferType?: 'deposit' | 'payment' | 'onramp'
  isCustomClientFeeProvided?: boolean
  /**
   * Amount in symbol after the client fees are applied. This field represents the exact amount
   * of the asset that will be requested for transfer.
   * @format double
   */
  amountWithCustomClientFee?: number
  /**
   * Indicates if all the fees are included in the amount. For example, if this field's value is `true`
   * and the user wants to send 1 BTC and the sum of all fees is 0.1 BTC, the user will be charged 1 BTC, and
   * the target address will receive 0.9 BTC.
   * If the fees are no inclusive, the user will be charged 1.1 BTC and the target address will receive 1 BTC.
   */
  isFeeIncluded?: boolean
  /**
   * Indicates the final amount to receive after all fees are applied. In case fees are not inclusive (`IsFeeIncluded` is `false`),
   * this field will be equal to the `Amount` field.
   * @format double
   */
  amountToReceive?: number
  /**
   * Indicates the final amount in fiat to receive after all fees are applied. In case fees are not inclusive (`IsFeeIncluded` is `false`),
   * this field will be equal to the `AmountInFiat` field.
   * @format double
   */
  amountToReceiveInFiat?: number
  /**
   * Exact amount in cryptocurrency requested to transfer to the destination address using the target integration.
   * @format double
   */
  transferAmountToRequest?: number
  /** Indicates if the transfer's intention is to transfer all available assets using the requested network and symbol. */
  isMaximumAmount?: boolean
  /** Indicates the fiat currency that is used to calculate transfer amounts. */
  fiatCurrency?: string | null
}

export type PreviewTransferStatus = 'succeeded' | 'failed' | 'requiresFunding'

export interface ProblemDetails {
  type?: string | null
  title?: string | null
  /** @format int32 */
  status?: number | null
  detail?: string | null
  instance?: string | null
  [key: string]: any
}

export interface ProcessingFeeRetainMethod {
  type?: 'default' | 'smartDeposit'
  processingFeeAddress?: string | null
}

export type ProcessingFeeRetainType = 'default' | 'smartDeposit'

export interface QuoteFees {
  /** Summary of all possible transfer fees in fiat */
  inFiat?: QuoteFeesInFiat | null
  /** Summary of all possible transfer fees in crypto */
  inCrypto?: QuoteFeesInCrypto | null
}

export interface QuoteFeesInCrypto {
  /**
   * Max fee charged if funded by payment method
   * @format double
   */
  paymentMethodFeeMax?: number
  /**
   * Max fee charged to buy crypto
   * @format double
   */
  tradingFeeMax?: number
  /**
   * Fee charged to withdraw crypto
   * @format double
   */
  withdrawalFee?: number
  /**
   * Fee charged by partner
   * @format double
   */
  partnerFee?: number
  /**
   * Fee charged for network transaction
   * @format double
   */
  networkFee?: number
  /**
   * Min of total fees charged in crypto
   * @format double
   */
  minFees?: number
  /**
   * Max of total fees charged in crypto
   * @format double
   */
  maxFees?: number
}

export interface QuoteFeesInFiat {
  /**
   * Max fee charged if funded by payment method
   * @format double
   */
  paymentMethodFeeMaxFiat?: number
  /**
   * Max fee charged to buy crypto
   * @format double
   */
  tradingFeeMaxFiat?: number
  /**
   * Fee charged to withdraw crypto
   * @format double
   */
  withdrawalFeeFiat?: number
  /**
   * Fee charged by partner
   * @format double
   */
  partnerFeeFiat?: number
  /**
   * Fee charged for network transaction
   * @format double
   */
  networkFeeFiat?: number
  /**
   * Min of total fees charged in fiat
   * @format double
   */
  minFeesFiat?: number
  /**
   * Max of total fees charged in fiat
   * @format double
   */
  maxFeesFiat?: number
}

export interface QuoteFundingOption {
  /** Funding option being quoted */
  fundingOption?:
    | 'existingCryptocurrencyBalance'
    | 'buyingPowerPurchase'
    | 'paymentMethodDepositUsage'
    | 'cryptocurrencyConversion'
    | 'stableCoinNoFeeConversion'
    | 'cryptocurrencyBuyingPowerConversion'
    | 'cryptocurrencyMultiStepConversion'
  /** Payment method being quoted for PaymentMethodDepositUsage funding option */
  paymentMethodType?: BrokerPaymentMethodType | null
  /**
   * Fee charged for this payment method
   * @format double
   */
  paymentMethodFeeFiat?: number
  /**
   * Fee charged to buy crypto if necessary for this funding option
   * @format double
   */
  tradingFeeFiat?: number
}

export interface QuoteTransferRequest {
  /**
   * Base amount of fiat currency being transferred
   * @format double
   */
  amountInFiat: number
  /**
   * 3 character currency code, e.g. USD
   * @minLength 0
   * @maxLength 3
   */
  fiatCurrency: string
  /**
   * Symbol of destination cryptocurrency, e.g. ETH
   * @minLength 0
   * @maxLength 10
   */
  symbol: string
  /**
   * Unique id of destination network
   * @format uuid
   */
  networkId: string
  /**
   * The designated destination for sending the asset.
   * @minLength 0
   * @maxLength 1024
   */
  toAddress: string
  /** The type of the integration to send the asset from */
  brokerType:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Flat fee in crypto to be charged as a partner fee
   * @format double
   */
  feeFlat?: number | null
  /**
   * Percentage of transfer amount to be charged as a partner fee, expressed as decimal (ie 0.1 = 10%)
   * @format double
   */
  feePercentage?: number | null
}

export interface QuoteTransferResponse {
  /**
   * Base amount of fiat currency being transferred (provided in request)
   * @format double
   */
  amountInFiat?: number
  /** 3 character currency code (provided in request) */
  fiatCurrency?: string | null
  /** Symbol of destination cryptocurrency (provided in request) */
  symbol?: string | null
  /**
   * Unique id of destination network (provided in request)
   * @format uuid
   */
  networkId?: string
  /** The designated destination for sending the asset. */
  toAddress?: string | null
  /** The type of the integration to send the asset from (provided in request) */
  brokerType?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Is the transaction is possible based on the minimum transfer amount of the selected exchange */
  isEligible?: boolean
  /**
   * Minimum amount eligible to transfer with selected asset, exchange, and network
   * @format double
   */
  minEligibleAmount?: number
  /**
   * Minimum amount in fiat eligible to transfer with selected asset, exchange, and network
   * @format double
   */
  minEligibleAmountFiat?: number
  /**
   * Maximum amount eligible to transfer with selected asset, exchange, and network
   * @format double
   */
  maxEligibleAmount?: number | null
  /**
   * Maximum amount eligible in fiat to transfer with selected asset, exchange, and network
   * @format double
   */
  maxEligibleAmountFiat?: number | null
  /** The reason a transaction is ineligible, returns none if eligible */
  ineligibilityReason?: NetworkTransferIneligibilityReason | null
  /**
   * Price quote from the broker, falls back to reference price
   * @format double
   */
  brokerPrice?: number
  /**
   * Reference price
   * @format double
   */
  price?: number
  /**
   * Min amount transferred in fiat
   * @format double
   */
  minAmountFiat?: number
  /**
   * Max amount transferred in fiat
   * @format double
   */
  maxAmountFiat?: number
  /**
   * Min amount of crypto transferred
   * @format double
   */
  minAmount?: number
  /**
   * Max amount of crypto transferred
   * @format double
   */
  maxAmount?: number
  /** Summary of all possible transfer fees */
  fees?: QuoteFees | null
  /** Summary of all possible funding options */
  fundingOptions?: QuoteFundingOption[] | null
}

export interface QuoteTransferResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: QuoteTransferResponse | null
}

export interface SmartContractTransferAllocation {
  /** Blockchain address of the Smart Contract */
  address?: string | null
  /**
   * The timestamp by which the transfer must be completely initiated. Currently, this means solving the MFA steps
   * @format int64
   */
  expirationTimestamp?: number
}

export type SymbolTradingAllowance =
  | 'fractionalTradingAllowed'
  | 'fractionalTradingNotAllowed'
  | 'tradingNotAllowed'
  | 'fractionalTradingPossiblyAllowed'

export interface TokenNetworksModel {
  token?: string | null
  networks?: NetworkResponseBase[] | null
  supportedIntegrations?: BrokerType[] | null
  integrationNetworks?: IntegrationNetwork[] | null
  tokenLogoUrl?: string | null
}

export interface TokenNetworksResponse {
  tokens?: TokenNetworksModel[] | null
}

export interface TokenNetworksResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: TokenNetworksResponse | null
}

export interface TransactionsB2BBrokerCreateOrderRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```ETrade```
   * ```Alpaca```
   * ```WeBull```
   * ```Stash```
   * ```InteractiveBrokers```
   * ```Public```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```Etoro```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```Vanguard```
   * ```BinanceInternationalDirect```
   * ```Bybit```
   * ```CoinbasePrime```
   * ```RobinhoodConnect```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Symbol to trade. For example, `AAPL` or `ETH`
   * @minLength 1
   */
  symbol: string
  /**
   * Symbol to use for payment, defaults to `USD`.
   * @minLength 1
   */
  paymentSymbol: string
  /**
   * Amount of purchase.
   * @format double
   */
  amount: number
  /**
   * Price of the unit, used for `Limit` and `StopLoss` orders.
   * @format double
   */
  price?: number
  /** Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly. */
  isCryptocurrency: boolean
  /** Indicates whether the `PaymentSymbol` is fiat or cryptocurrency */
  paymentIsCryptocurrency: boolean
  /** @deprecated */
  amountIsFiat?: boolean | null
  /**
   * @deprecated
   * @format double
   */
  amountInFiat?: number | null
  /**
   * This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be
   * performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and
   * `SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`
   * value is passed.
   */
  amountIsInPaymentSymbol: boolean
  /**
   * Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`
   * and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
   * @format double
   */
  amountInPaymentSymbol?: number | null
  /** Specifies if the extended trading hours should be used. */
  extendedHours?: boolean
  orderType: 'market' | 'limit' | 'stopLoss'
  timeInForce: 'goodTillCanceled' | 'immediateOrCancel' | 'fillOrKill' | 'goodForDay' | 'postOnly' | 'unknown'
  /** MFA Code to create an order (requested by Kraken if MFA is enabled in user settings) */
  mfaCode?: string | null
}

export interface TransactionsB2BBrokerOrderListRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```ETrade```
   * ```Alpaca```
   * ```WeBull```
   * ```Stash```
   * ```InteractiveBrokers```
   * ```Public```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```Etoro```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```Vanguard```
   * ```BinanceInternationalDirect```
   * ```Bybit```
   * ```CoinbasePrime```
   * ```RobinhoodConnect```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * The cursor to retrieve the next page of transactions.
   * Providing it will cause the response to only return changes after this update.
   * If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
   */
  cursor?: string | null
  /**
   * Number of records to include in the response.
   *
   * Default: `100`
   *
   * Maximum: `250`
   * @format int32
   */
  count?: number
  /** Return orders of this statuses only. If this field is not provided, orders with all available statuses will be returned. */
  statuses?: BrokerOrderStatus[] | null
  /**
   * Return orders created after this timestamp.
   * If this field is not provided, orders will be returned according to the default of the institution.
   * @format int64
   */
  from?: number | null
}

export interface TransactionsB2BBrokerOrderRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```ETrade```
   * ```Alpaca```
   * ```WeBull```
   * ```Stash```
   * ```InteractiveBrokers```
   * ```Public```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```Etoro```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```Vanguard```
   * ```BinanceInternationalDirect```
   * ```Bybit```
   * ```CoinbasePrime```
   * ```RobinhoodConnect```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** @minLength 1 */
  id: string
  /** Should be provided for Coinbase. */
  side?: BrokerOrderType | null
  /** Some Stock and Crypto symbols can intersect, so we need to explicitly specify what type of asset is requested to be bought. */
  isCryptocurrency: boolean
  /** Symbol pair of the order (requested by some brokers). */
  symbolPair?: string | null
  /** MFA Code to cancel an order (requested by Kraken if MFA is enabled in user settings) */
  mfaCode?: string | null
}

export interface TransactionsB2BBrokerSymbolInfoForOrderRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```ETrade```
   * ```Alpaca```
   * ```WeBull```
   * ```Stash```
   * ```InteractiveBrokers```
   * ```Public```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```Etoro```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```Vanguard```
   * ```BinanceInternationalDirect```
   * ```Bybit```
   * ```CoinbasePrime```
   * ```RobinhoodConnect```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Symbol to trade. For example, `AAPL` or `ETH`
   * @minLength 1
   */
  symbol: string
  /**
   * Symbol to use for payment, defaults to `USD`.
   * @minLength 1
   */
  paymentSymbol: string
  /**
   * Amount of purchase.
   * @format double
   */
  amount: number
  /**
   * Price of the unit, used for `Limit` and `StopLoss` orders.
   * @format double
   */
  price?: number
  /** Some Stock and Crypto symbols can intersect, so the type of the asset needs to be specified explicitly. */
  isCryptocurrency: boolean
  /** Indicates whether the `PaymentSymbol` is fiat or cryptocurrency */
  paymentIsCryptocurrency: boolean
  /** @deprecated */
  amountIsFiat?: boolean | null
  /**
   * @deprecated
   * @format double
   */
  amountInFiat?: number | null
  /**
   * This value indicates if the order should be executed in payment/quote currency amount (e.g. purchase ETH for $10). This can be
   * performed only if the current institution supports such orders (`SupportsPlacingSellOrdersInPaymentSymbolAmount` and
   * `SupportsPlacingBuyOrdersInPaymentSymbolAmount` fields in `get supported order features for institution`) and `AmountInPaymentSymbol`
   * value is passed.
   */
  amountIsInPaymentSymbol: boolean
  /**
   * Specifies the target amount in the payment/quote currency. For example, setting this to `10` when the `AmountInPaymentSymbol` = `true`
   * and `PaymentSymbol` = `USD` will instruct the API to place an order to buy/sell the asset worth $10.
   * @format double
   */
  amountInPaymentSymbol?: number | null
  /** Specifies if the extended trading hours should be used. */
  extendedHours?: boolean
  orderType: 'market' | 'limit' | 'stopLoss'
  timeInForce: 'goodTillCanceled' | 'immediateOrCancel' | 'fillOrKill' | 'goodForDay' | 'postOnly' | 'unknown'
  /** MFA Code to create an order (requested by Kraken if MFA is enabled in user settings) */
  mfaCode?: string | null
  side?: BrokerOrderType | null
}

export interface TransactionsBrokerBaseRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```ETrade```
   * ```Alpaca```
   * ```WeBull```
   * ```Stash```
   * ```InteractiveBrokers```
   * ```Public```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```Etoro```
   * ```CexIo```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```BitFlyer```
   * ```Coinlist```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```Vanguard```
   * ```BinanceInternationalDirect```
   * ```Bybit```
   * ```CoinbasePrime```
   * ```RobinhoodConnect```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
}

export interface TransferBalanceFundingAvailability {
  status?: 'disabled' | 'available' | 'requiresAmountLowering' | 'notApplicable' | 'unavailable'
  /**
   * The total transfer amount in crypto after all fees are applied
   * @format double
   */
  transferTotalAmount?: number
  /**
   * The price of the cryptocurrency asset in the fiat currency.
   * @format double
   */
  unitPrice?: number
  /** Represents the safety margin amount to cover gas fee volatility. */
  gasFeeBuffer?: TransferFee | null
  symbol?: string | null
  /**
   * The total transfer amount in fiat after all fees are applied.
   * @format double
   */
  transferTotalAmountInFiat?: number
}

export interface TransferBalanceFundingAvailabilityBase {
  status?: 'disabled' | 'available' | 'requiresAmountLowering' | 'notApplicable' | 'unavailable'
}

export type TransferBalanceFundingAvailabilityStatus =
  | 'disabled'
  | 'available'
  | 'requiresAmountLowering'
  | 'notApplicable'
  | 'unavailable'

export interface TransferCryptocurrencyFundingOptions {
  /**
   * Indicates whether the Link is permitted to use the end user's available buying power
   * and/or payment methods to supplement the cryptocurrency balance if it is insufficient
   * for the transfer.
   */
  enabled?: boolean
}

export interface TransferFee {
  /**
   * The amount of the fee.
   * @format double
   */
  fee?: number
  /** The currency of the fee. Does not match the currency of the transfer in some cases. */
  feeCurrency?: string | null
  /**
   * The value of the fee converted to the fiat currency.
   * @format double
   */
  feeInFiat?: number
}

export interface TransferFromAnotherAccountAvailabilityInfo {
  transferFromAnotherAccountNeeded?: boolean
  /** @format double */
  transferFromAnotherAccountAmount?: number
  anotherAccountName?: string | null
}

/** Funding method model. */
export interface TransferFundingModel {
  /** Type of the funding method. */
  type?:
    | 'existingCryptocurrencyBalance'
    | 'buyingPowerPurchase'
    | 'paymentMethodDepositUsage'
    | 'cryptocurrencyConversion'
    | 'stableCoinNoFeeConversion'
    | 'cryptocurrencyBuyingPowerConversion'
    | 'cryptocurrencyMultiStepConversion'
  /**
   * Amount funded.
   * @format double
   */
  amount?: number
  /**
   * Amount in fiat.
   * @format double
   */
  amountInFiat?: number
  /** Symbol purchased. */
  toSymbol?: string | null
  /**
   * Amount used.
   * @format double
   */
  fromAmount?: number
  /** Symbol used. */
  fromSymbol?: string | null
  /** Payment method type */
  paymentMethodType?: BrokerPaymentMethodType | null
  /** Fee of funding. */
  fee?: TransferFee | null
}

/** Integration model. */
export interface TransferIntegrationModel {
  /**
   * Unique identifier of integration.
   * @format uuid
   */
  id?: string
  /** Type of integration. */
  type?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Name of integration. */
  name?: string | null
}

export interface TransferIntegrationWithLogoModel {
  /**
   * Unique identifier of integration.
   * @format uuid
   */
  id?: string
  /** Type of integration. */
  type?:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Name of integration. */
  name?: string | null
  /** Integration logo URL. */
  logoUrl?: string | null
}

export interface TransferModel {
  /**
   * Mesh transfer identifier.
   * @format uuid
   */
  id?: string
  /** Client transaction identifier. */
  clientTransactionId?: string | null
  /** Integration transaction identifier. */
  institutionTransactionId?: string | null
  /** Client's user identifier. */
  userId?: string | null
  /** Transfer status. */
  status?: 'pending' | 'succeeded' | 'failed'
  /**
   * Transfer amount in fiat.
   * @format double
   */
  amountInFiat?: number
  /**
   * Actual transfer amount without fees in fiat.
   * @format double
   */
  amountToReceiveInFiat?: number
  /** Transfer amount in fiat currency code. */
  amountInFiatCurrencyCode?: string | null
  /**
   * Transfer amount.
   * @format double
   */
  amount?: number
  /**
   * Actual transfer amount without fees.
   * @format double
   */
  amountToReceive?: number
  /** Transfer cryptocurrency symbol. */
  symbol?: string | null
  /** Transfer cryptocurrency token contract address (e.g., for ERC20s). */
  tokenAddress?: string | null
  /** Transfer network name. */
  networkName?: string | null
  /**
   * Id of the transfer network.
   * @format uuid
   */
  networkId?: string
  /** Network logo URL. */
  networkLogoUrl?: string | null
  /**
   * Created timestamp.
   * @format int64
   */
  createdTimestamp?: number
  /** From integration. */
  from?: TransferIntegrationWithLogoModel | null
  /** Transfer hash. */
  hash?: string | null
  /**
   * Transfer info url on blockchain explorer.
   * @format uri
   */
  infoUrl?: string | null
  /** Transfer network gas fee. */
  gasFee?: TransferFee | null
  /** Financial insitution withdrawal fee. */
  withdrawalFee?: TransferFee | null
  /** Transfer processing fee. */
  processingFee?: TransferFee | null
  /**
   * Transfer executed Unix timestamp.
   * @format int64
   */
  executedTimestamp?: number | null
  /** Type of a transfer. */
  transferType?: TransferTypeEnum | null
  /** Is fee included. */
  isFeeIncluded?: boolean
  /**
   * Amount what was actually transferred from source account.
   * @format double
   */
  sourceAmount?: number | null
  /**
   * Amount what destination actually received.
   * @format double
   */
  destinationAmount?: number | null
  /**
   * Amount in fiat what destination actually received.
   * @format double
   */
  destinationAmountInFiat?: number | null
  /**
   * Total fees paid by user to execute this transaction.
   * @format double
   */
  readonly totalFeesAmountInFiat?: number
  /**
   * Total fiat transaction amount in origin integration.
   * @format double
   */
  readonly totalTransactionAmountInFiat?: number
  /** The funding methods that were used to fund the transaction. */
  fundingMethods?: TransferFundingModel[] | null
  /** Transfer Destination Address. */
  destinationAddress?: string | null
}

export interface TransferModelPaginationResponse {
  /** list of items */
  items?: TransferModel[] | null
  /**
   * Total number of items
   * @format int32
   */
  total?: number
}

export interface TransferModelPaginationResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: TransferModelPaginationResponse | null
}

export type TransferOrderByFields =
  | 'id'
  | 'clientTransferId'
  | 'userId'
  | 'fromType'
  | 'amountInFiat'
  | 'status'
  | 'createdTimestamp'
  | 'symbol'
  | 'networkName'

export type TransferStatus = 'pending' | 'succeeded' | 'failed'

export interface TransferToAddress {
  /**
   * The Id of the network in Front system. The list of all available networks can be obtained by
   * using `GET /transfers/managed/networks` endpoint.
   * @format uuid
   */
  networkId?: string
  /** The symbol of the digital asset. */
  symbol?: string | null
  /** The address to send the asset to. */
  address?: string | null
  /** Secondary address identifier for coins like XRP,XMR etc. */
  addressTag?: string | null
}

export interface TransferToAddressWithAmount {
  /**
   * The Id of the network in Front system. The list of all available networks can be obtained by
   * using `GET /transfers/managed/networks` endpoint.
   * @format uuid
   */
  networkId?: string
  /** The symbol of the digital asset. */
  symbol?: string | null
  /** The address to send the asset to. */
  address?: string | null
  /** Secondary address identifier for coins like XRP,XMR etc. */
  addressTag?: string | null
  /**
   * Amount of tokens to transfer by specified network.
   * @format double
   */
  amount?: number | null
}

export interface TransferTravelRuleOptions {
  clientName?: string | null
  transferType?: TransferTypeEnum | null
  clientType?:
    | 'undefined'
    | 'wallet'
    | 'exchange'
    | 'vasp'
    | 'merchant'
    | 'other'
    | 'psp'
    | 'neobank'
    | 'iGaming'
    | 'aggregator'
}

export type TransferTypeEnum = 'deposit' | 'payment' | 'onramp'

export interface TransferVerificationRequest {
  integrationId?: string | null
  token?: string | null
  networkId?: string | null
  targetAddress?: string | null
}

export interface TransferVerificationResponse {
  status?: 'succeeded' | 'failed'
  errorMessage?: string | null
  failureReason?: FailureReason | null
}

export interface TransferVerificationResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: TransferVerificationResponse | null
}

export type TransferVerifyStatus = 'succeeded' | 'failed'

export interface TransfersBrokerCreateCryptocurrencyTransactionRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```BinanceInternationalDirect```
   * ```BitfinexDirect```
   * ```Bybit```
   * ```Paxos```
   * ```CoinbasePrime```
   * ```BtcTurkDirect```
   * ```ParibuDirect```
   * ```RobinhoodConnect```
   * ```BlockchainCom```
   * ```BinanceConnect```
   * ```RevolutConnect```
   * ```BinancePay```
   * ```DeFiWallet```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Additional data to send on-chain (optional, depends on an integration) */
  data?: string | null
  /**
   * Target address to transfer the asset to
   * @minLength 1
   */
  targetAddress: string
  /**
   * Amount to transfer
   * @format double
   */
  amount?: number
  /**
   * On-chain fee (optional, depends on an integration)
   * @format double
   */
  fee?: number
  /**
   * Type of the address of symbol to be transferred. Providing `EthAddress` will initiate a transfer of ETH over Ethereum blockchain.
   * Can be used instead of `Symbol` and `Chain` fields.
   * To transfer assets over non-default chains (e.g. sending USDT over ERC20) please `Symbol` and `Chain` fields.
   */
  addressType?: CryptocurrencyAddressType | null
  /** 2 Factor auth code (optional, depends on an integration) */
  mfaCode?: string | null
  /**
   * Travel rule transaction id (optional, depends on an integration)
   * @format int32
   */
  travelRuleTransactionId?: number | null
  /** 2 Factor auth type (optional, depends on an integration) */
  mfaType?: MfaType | null
  verificationSteps?: MfaType[] | null
  /** Password or pass-phrase, required to send transfers (optional, depends on an integration) */
  password?: string | null
  /**
   * Custom chain name, required by some of the integrations. E.g. USDT can be sent over USDT-ERC20, USDT-TRC20, and USDT-Omni.
   * Can be used to transfer assets over non-default chains (e.g. sending USDT over ERC20).
   * Please use `symbol/details` endpoint to get the list of all possible chains.
   */
  chain?: string | null
  /** Memo (also called "Tag") - address remark. */
  memo?: string | null
  /** Symbol to be transferred. Can be provided instead of the `AddressType` field. */
  symbol?: string | null
  challengeId?: string | null
  tryAnotherMfa?: boolean
  travelRuleOptions?: TransferTravelRuleOptions | null
}

export interface TransfersBrokerCryptocurrencyDepositAddressRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```BinanceInternationalDirect```
   * ```BitfinexDirect```
   * ```Bybit```
   * ```Paxos```
   * ```CoinbasePrime```
   * ```BtcTurkDirect```
   * ```ParibuDirect```
   * ```RobinhoodConnect```
   * ```BlockchainCom```
   * ```BinanceConnect```
   * ```RevolutConnect```
   * ```BinancePay```
   * ```DeFiWallet```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Symbol of the required cryptocurrency, e.g. ETH or BTC.
   * Can be used instead of the `AddressType` field.
   */
  symbol?: string | null
  /**
   * Type of the address of symbol to be transferred. Providing `EthAddress` will assume a transfer of ETH over Ethereum blockchain.
   * Can be used instead of `Symbol` field.
   */
  addressType?: CryptocurrencyAddressType | null
  /** Chain of the required cryptocurrency, e.g. USDT has USDT-ERC20, USDT-TRC20, and USDT-Omni */
  chain?: string | null
  /** Some of integrations require MFA code to create a deposit address, e.g. KrakenDirect */
  mfaCode?: string | null
}

export interface TransfersBrokerCryptocurrencyTransactionDetailsRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```BinanceInternationalDirect```
   * ```BitfinexDirect```
   * ```Bybit```
   * ```Paxos```
   * ```CoinbasePrime```
   * ```BtcTurkDirect```
   * ```ParibuDirect```
   * ```RobinhoodConnect```
   * ```BlockchainCom```
   * ```BinanceConnect```
   * ```RevolutConnect```
   * ```BinancePay```
   * ```DeFiWallet```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /** Type of the address of the transferred asset. Can be used instead of the `Symbol` field. */
  addressType?: CryptocurrencyAddressType | null
  /** Transaction Id by the financial institution */
  transactionId?: string | null
  /** Hash of the transaction on the blockchain */
  transactionHash?: string | null
  /** Symbol of the transferred asset. Can be provided instead of the `AddressType` field. */
  symbol?: string | null
}

export interface TransfersBrokerTransactionsListRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /**
   * Type of the institution to connect
   *
   * ### Supported integrations:
   * ```Robinhood```
   * ```Coinbase```
   * ```Kraken```
   * ```CoinbasePro```
   * ```CryptoCom```
   * ```Binance```
   * ```Gemini```
   * ```OkCoin```
   * ```KuCoin```
   * ```BinanceInternational```
   * ```Bitstamp```
   * ```GateIo```
   * ```Okx```
   * ```Huobi```
   * ```Bitfinex```
   * ```KrakenDirect```
   * ```BinanceInternationalDirect```
   * ```BitfinexDirect```
   * ```Bybit```
   * ```Paxos```
   * ```CoinbasePrime```
   * ```BtcTurkDirect```
   * ```ParibuDirect```
   * ```RobinhoodConnect```
   * ```BlockchainCom```
   * ```BinanceConnect```
   * ```RevolutConnect```
   * ```BinancePay```
   * ```DeFiWallet```
   */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Number of records to include in the response.
   *
   * Default: `100`
   *
   * Maximum: `250`
   * @format int32
   */
  count?: number
  /**
   * The cursor to retrieve the next page of transactions.
   * Providing it will cause the response to only return changes after this update.
   * If this field is not provided, the history of transactions will be returned starting with the first-added transaction.
   */
  cursor?: string | null
  /** If this value is provided, result set is filtered to only include transaction with the provided statuses. */
  statuses?: BrokerCryptocurrencyTransactionStatus[] | null
  /** For cryptocurrency address the type of address is required. */
  cryptocurrencyAddressType?: CryptocurrencyAddressType | null
  /**
   * If this value is provided, result set is filtered to only include transactions created after this timestamp
   * @format int64
   */
  from?: number | null
}

export interface UpdateTransferModel {
  /**
   * Mesh transfer identifier.
   * @format uuid
   */
  id?: string
  /** Client transaction identifier. */
  clientTransactionId?: string | null
  /** Integration transaction identifier. */
  institutionTransactionId?: string | null
  /** Client's user identifier. */
  userId?: string | null
  /** Transfer status. */
  status?: 'pending' | 'succeeded' | 'failed'
  /**
   * Transfer amount in fiat.
   * @format double
   */
  amountInFiat?: number
  /** Transfer amount in fiat currency code. */
  amountInFiatCurrencyCode?: string | null
  /**
   * Transfer amount.
   * @format double
   */
  amount?: number
  /** Transfer cryptocurrency symbol. */
  symbol?: string | null
  /** Transfer network name. */
  networkName?: string | null
  /**
   * Created timestamp.
   * @format int64
   */
  createdTimestamp?: number
  /** From integration. */
  from?: TransferIntegrationModel | null
  /** Transfer hash. */
  hash?: string | null
  /**
   * Transfer executed Unix timestamp.
   * @format int64
   */
  executedTimestamp?: number | null
}

export interface UpdateTransferResponse {
  /** The status of the transfer. */
  status?: 'pending' | 'succeeded' | 'failed'
  /** The status details of the transfer. */
  statusDetails?:
    | 'unknown'
    | 'failed'
    | 'frozen'
    | 'succeeded'
    | 'mfaRequired'
    | 'pending'
    | 'expired'
    | 'canceled'
    | 'waitingForSignature'
    | 'waitingForClearing'
    | 'awaitingApproval'
    | 'awaitingConfirmation'
    | 'awaitingVerification'
    | 'rejected'
    | 'pendingCancel'
    | 'emailVerification'
    | 'deviceConfirmationRequired'
    | 'mfaFailed'
    | 'addressWhitelistRequired'
    | 'secondMfaRequired'
    | 'emailConfirmationApprovalRequired'
  /** Error message, if the operation did not complete successfully. */
  errorMessage?: string | null
  /** Result of the transfer initiation. */
  transferResult?: UpdateTransferModel | null
}

export interface UpdateTransferResponseApiResult {
  readonly status?:
    | 'ok'
    | 'serverFailure'
    | 'permissionDenied'
    | 'badRequest'
    | 'notFound'
    | 'conflict'
    | 'tooManyRequest'
    | 'locked'
    | 'unavailableForLegalReasons'
  /** A message generated by the API */
  message?: string | null
  /** User-friendly display message that can be presented to the end user */
  displayMessage?: string | null
  /**
   * Strictly-typed error type that is explaining the reason of an unsuccessful status of the operation.
   * All possible error types are available in the documentation.
   */
  errorType?: string | null
  readonly errorData?: any
  content?: UpdateTransferResponse | null
}

export interface UpdateTransferStatusRequest {
  /**
   * Auth token that allows connecting to the target institution
   * @minLength 1
   */
  authToken: string
  /** Type of the institution to connect */
  type:
    | 'robinhood'
    | 'eTrade'
    | 'alpaca'
    | 'tdAmeritrade'
    | 'weBull'
    | 'stash'
    | 'interactiveBrokers'
    | 'public'
    | 'coinbase'
    | 'kraken'
    | 'coinbasePro'
    | 'cryptoCom'
    | 'openSea'
    | 'binanceUs'
    | 'gemini'
    | 'cryptocurrencyAddress'
    | 'cryptocurrencyWallet'
    | 'okCoin'
    | 'bittrex'
    | 'kuCoin'
    | 'etoro'
    | 'cexIo'
    | 'binanceInternational'
    | 'bitstamp'
    | 'gateIo'
    | 'acorns'
    | 'okx'
    | 'bitFlyer'
    | 'coinlist'
    | 'huobi'
    | 'bitfinex'
    | 'deFiWallet'
    | 'krakenDirect'
    | 'vanguard'
    | 'binanceInternationalDirect'
    | 'bitfinexDirect'
    | 'bybit'
    | 'paxos'
    | 'coinbasePrime'
    | 'btcTurkDirect'
    | 'kuCoinDirect'
    | 'okxOAuth'
    | 'paribuDirect'
    | 'robinhoodConnect'
    | 'blockchainCom'
    | 'bitsoDirect'
    | 'binanceConnect'
    | 'binanceOAuth'
    | 'revolutConnect'
    | 'binancePay'
    | 'bybitDirect'
    | 'paribuOAuth'
    | 'payPalConnect'
  /**
   * Id of the executed transfer.
   * @minLength 1
   */
  transactionId: string
}

export type UserIdentificationType = 'none' | 'idCard' | 'driversLicense' | 'passport'

/** DeFi wallet verification options. */
export interface VerifyWalletOptions {
  /**
   * Verification message to sign.
   * Required if `signedMessage` is provided in <paramref name="VerificationMethods">VerificationMethods</paramref> list.
   */
  message?: string | null
  /** List or required verification methods. By default - sign message with wallet key. */
  verificationMethods?: WalletVerificationMethod[] | null
  /** Addresses list to verify. If user verifies another address then verification will be failed. */
  addresses?: string[] | null
  /**
   * Network to verify. If user verifies another network address then verification will be failed.
   * Checked only if Addresses is provided.
   * @format uuid
   */
  networkId?: string | null
  /**
   * Network type to verify. If user verifies another network address then verification will be failed.
   * Checked only if Addresses is provided.
   */
  networkType?: NetworkType | null
}

/** Verification method. */
export type WalletVerificationMethod = 'signedMessage'

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, HeadersDefaults, ResponseType } from 'axios'

export type QueryParamsType = Record<string | number, any>

export interface FullRequestParams extends Omit<AxiosRequestConfig, 'data' | 'params' | 'url' | 'responseType'> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean
  /** request path */
  path: string
  /** content type of request body */
  type?: ContentType
  /** query params */
  query?: QueryParamsType
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseType
  /** request body */
  body?: unknown
}

export type RequestParams = Omit<FullRequestParams, 'body' | 'method' | 'query' | 'path'>

export interface ApiConfig<SecurityDataType = unknown> extends Omit<AxiosRequestConfig, 'data' | 'cancelToken'> {
  securityWorker?: (
    securityData: SecurityDataType | null
  ) => Promise<AxiosRequestConfig | void> | AxiosRequestConfig | void
  secure?: boolean
  format?: ResponseType
}

export enum ContentType {
  Json = 'application/json',
  FormData = 'multipart/form-data',
  UrlEncoded = 'application/x-www-form-urlencoded',
  Text = 'text/plain'
}

export class HttpClient<SecurityDataType = unknown> {
  public instance: AxiosInstance
  private securityData: SecurityDataType | null = null
  private securityWorker?: ApiConfig<SecurityDataType>['securityWorker']
  private secure?: boolean
  private format?: ResponseType

  constructor({ securityWorker, secure, format, ...axiosConfig }: ApiConfig<SecurityDataType> = {}) {
    this.instance = axios.create({
      ...axiosConfig,
      baseURL: axiosConfig.baseURL || 'https://integration-api.meshconnect.com'
    })
    this.secure = secure
    this.format = format
    this.securityWorker = securityWorker
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data
  }

  protected mergeRequestParams(params1: AxiosRequestConfig, params2?: AxiosRequestConfig): AxiosRequestConfig {
    const method = params1.method || (params2 && params2.method)

    return {
      ...this.instance.defaults,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...((method && this.instance.defaults.headers[method.toLowerCase() as keyof HeadersDefaults]) || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {})
      }
    }
  }

  protected stringifyFormItem(formItem: unknown) {
    if (typeof formItem === 'object' && formItem !== null) {
      return JSON.stringify(formItem)
    } else {
      return `${formItem}`
    }
  }

  protected createFormData(input: Record<string, unknown>): FormData {
    return Object.keys(input || {}).reduce((formData, key) => {
      const property = input[key]
      const propertyContent: any[] = property instanceof Array ? property : [property]

      for (const formItem of propertyContent) {
        const isFileType = formItem instanceof Blob || formItem instanceof File
        formData.append(key, isFileType ? formItem : this.stringifyFormItem(formItem))
      }

      return formData
    }, new FormData())
  }

  public request = async <T = any, _E = any>({
    secure,
    path,
    type,
    query,
    format,
    body,
    ...params
  }: FullRequestParams): Promise<AxiosResponse<T>> => {
    const secureParams =
      ((typeof secure === 'boolean' ? secure : this.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {}
    const requestParams = this.mergeRequestParams(params, secureParams)
    const responseFormat = format || this.format || undefined

    if (type === ContentType.FormData && body && body !== null && typeof body === 'object') {
      body = this.createFormData(body as Record<string, unknown>)
    }

    if (type === ContentType.Text && body && body !== null && typeof body !== 'string') {
      body = JSON.stringify(body)
    }

    return this.instance.request({
      ...requestParams,
      headers: {
        ...(requestParams.headers || {}),
        ...(type && type !== ContentType.FormData ? { 'Content-Type': type } : {})
      },
      params: query,
      responseType: responseFormat,
      data: body,
      url: path
    })
  }
}

/**
 * @title Mesh Connect Integration API
 * @version 1.0
 * @baseUrl https://integration-api.meshconnect.com
 *
 *
 * Mesh allows users to connect accounts of financial institutions,
 * crypto exchanges, and self-custody wallets. Mesh handles credential
 * validation, MFA, and error handling for each integration. After
 * an account is connected, Mesh allows client applications to read holdings,
 * transaction history and balances and execute crypto transfers (with user approval).
 */
export class FrontApi<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
  integrationsAccountInformation = {
    /**
     * @description Return KYC details of the user.
     *
     * @tags Integrations account information
     * @name V1AccountVerifyCreate
     * @summary Verify account identity. Replaced by exchange/verify endpoint.
     * @request POST:/api/v1/account/verify
     * @deprecated
     * @secure
     * @response `200` `B2BBrokerAccountDetailsResponseApiResult` Successfully returns account details.
     * @response `400` `ApiResult` Request to retrieve account details is not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `403` `any` Forbidden
     */
    v1AccountVerifyCreate: (data: B2BBrokerAccountDetailsRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerAccountDetailsResponseApiResult, ApiResult>({
        path: `/api/v1/account/verify`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Returns basic profile data of the user's exchange account. Available data varies by exchange and linked account.
     *
     * @tags Integrations account information
     * @name V1ExchangeVerifyCreate
     * @summary Verify account identity.
     * @request POST:/api/v1/exchange/verify
     * @secure
     * @response `200` `B2BBrokerAccountDetailsResponseApiResult` Successfully returns account details.
     * @response `400` `ApiResult` Request to retrieve account details is not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `403` `any` Forbidden
     */
    v1ExchangeVerifyCreate: (data: ExchangeAccountInfoRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerAccountDetailsResponseApiResult, ApiResult>({
        path: `/api/v1/exchange/verify`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      })
  }
  assets = {
    /**
     * No description
     *
     * @tags Assets
     * @name V1AssetsDetail
     * @summary Get available assets
     * @request GET:/api/v1/assets/{assetType}
     * @secure
     * @response `200` `AssetPaginationResponseApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1AssetsDetail: (
      assetType: 'equity' | 'cryptocurrency',
      query?: {
        Search?: string
        /** @format int32 */
        Count?: number
        /** @format int32 */
        Offset?: number
      },
      params: RequestParams = {}
    ) =>
      this.request<AssetPaginationResponseApiResult, ApiResult>({
        path: `/api/v1/assets/${assetType}`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * No description
     *
     * @tags Assets
     * @name V1AssetsEquityPriceDetail
     * @summary Get symbol price
     * @request GET:/api/v1/assets/equity/{symbol}/price
     * @secure
     * @response `200` `B2BPriceInfoApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1AssetsEquityPriceDetail: (symbol: string, params: RequestParams = {}) =>
      this.request<B2BPriceInfoApiResult, ApiResult>({
        path: `/api/v1/assets/equity/${symbol}/price`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      })
  }
  balance = {
    /**
     * @description Get real-time account fiat balances.
     *
     * @tags Balance
     * @name V1BalanceGetCreate
     * @summary Get account balance
     * @request POST:/api/v1/balance/get
     * @secure
     * @response `200` `B2BBrokerAccountBalanceModelApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     * @response `403` `any` The API key used does not have read permission to call this Mesh endpoint.
     */
    v1BalanceGetCreate: (data: BalanceBrokerBaseRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerAccountBalanceModelApiResult, ApiResult>({
        path: `/api/v1/balance/get`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get cached aggregated fiat balances from all connected integrations.
     *
     * @tags Balance
     * @name V1BalancePortfolioList
     * @summary Get aggregated portfolio fiat balances
     * @request GET:/api/v1/balance/portfolio
     * @secure
     * @response `200` `B2BFiatPortfolioModelApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     * @response `403` `any` The API key used does not have read permission to call this Mesh endpoint.
     */
    v1BalancePortfolioList: (
      query?: {
        /** End user ID to get the aggregated portfolio for. */
        UserId?: string
      },
      params: RequestParams = {}
    ) =>
      this.request<B2BFiatPortfolioModelApiResult, ApiResult>({
        path: `/api/v1/balance/portfolio`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      })
  }
  managedAccountAuthentication = {
    /**
     * @description Get personalized catalog link for client
     *
     * @tags Managed Account Authentication
     * @name V1CataloglinkList
     * @summary Get catalog link
     * @request GET:/api/v1/cataloglink
     * @deprecated
     * @secure
     * @response `200` `CatalogLinkApiResult` Catalog link created.
     * @response `400` `ApiResult` BadRequest can happen in following cases: <list type="number"><item><description>userId parameter not specified</description></item><item><description>Callback url parameter is invalid</description></item><item><description>Client does not have callback url specified</description></item></list>
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` API Client not found.
     */
    v1CataloglinkList: (
      query: {
        /**
         * A unique Id representing the end user. Typically this will be a user Id from the
         * client application. Personally identifiable information, such as an email address or phone number,
         * should not be used. 50 characters length maximum.
         * @maxLength 50
         */
        UserId: string
        /**
         * Type of integration to redirect to. Will redirect to catalog if not provided.
         * Not supported types: DeFiWallet, CryptocurrencyAddress, CryptocurrencyWallet.
         */
        BrokerType?: BrokerType
        /**
         * Link Configuration identifier - an optional paramater for used configuration.
         * If not provided default configuration with all avaialbe integrations will be used.
         */
        EnableTransfers?: boolean
        /**
         * The final screen of Link allows users to continue back to your app or Link another account.
         * If this param is present then this button will be hidden.
         */
        RestrictMultipleAccounts?: boolean
        /**
         * For direct integrations that also support API keys, Link presents the user with the option to generate an API key for seamless access.
         * If this param is true, this feature will be disabled.
         */
        DisableApiKeyGeneration?: boolean
      },
      params: RequestParams = {}
    ) =>
      this.request<CatalogLinkApiResult, ApiResult>({
        path: `/api/v1/cataloglink`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description Get personalized catalog link for client supplying parameters for Link actions, such as transfers
     *
     * @tags Managed Account Authentication
     * @name V1CataloglinkCreate
     * @summary Get catalog link with parameters
     * @request POST:/api/v1/cataloglink
     * @deprecated
     * @secure
     * @response `200` `CatalogLinkApiResult` Catalog link created.
     * @response `400` `ApiResult` BadRequest can happen in following cases: <list type="number"><item><description>userId parameter not specified</description></item><item><description>Callback url parameter is invalid</description></item><item><description>Client does not have callback url specified</description></item></list>
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` API Client not found.
     */
    v1CataloglinkCreate: (
      query: {
        /**
         * A unique Id representing the end user. Typically this will be a user Id from the
         * client application. Personally identifiable information, such as an email address or phone number,
         * should not be used. 50 characters length maximum.
         * @maxLength 50
         */
        UserId: string
        /**
         * Type of integration to redirect to. Will redirect to catalog if not provided.
         * Not supported types: DeFiWallet, CryptocurrencyAddress, CryptocurrencyWallet.
         */
        BrokerType?: BrokerType
        /**
         * Link Configuration identifier - an optional paramater for used configuration.
         * If not provided default configuration with all avaialbe integrations will be used.
         */
        EnableTransfers?: boolean
        /**
         * The final screen of Link allows users to continue back to your app or Link another account.
         * If this param is present then this button will be hidden.
         */
        RestrictMultipleAccounts?: boolean
        /**
         * For direct integrations that also support API keys, Link presents the user with the option to generate an API key for seamless access.
         * If this param is true, this feature will be disabled.
         */
        DisableApiKeyGeneration?: boolean
      },
      data: InitializeTransfersForLinkRequest,
      params: RequestParams = {}
    ) =>
      this.request<CatalogLinkApiResult, ApiResult>({
        path: `/api/v1/cataloglink`,
        method: 'POST',
        query: query,
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get a short lived, one-time use token for initializing a Link session using the client-side SDKs
     *
     * @tags Managed Account Authentication
     * @name V1LinktokenCreate
     * @summary Get Link token with parameters
     * @request POST:/api/v1/linktoken
     * @secure
     * @response `200` `LinkTokenModelApiResult` Link token created.
     * @response `400` `ApiResult` BadRequest can happen in following cases: <list type="number"><item><description>userId parameter not specified</description></item></list>
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` API Client not found.
     */
    v1LinktokenCreate: (data: GetLinkTokenRequest, params: RequestParams = {}) =>
      this.request<LinkTokenModelApiResult, ApiResult>({
        path: `/api/v1/linktoken`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Refresh auth token of the connected institution. Some institutions do not require tokens to be refreshed. The following institutions require custom flows: WeBull: AuthToken should be provided along with the RefreshToken Vanguard: security settings may activate MFA, requiring user action. If MFA is triggered, a second refresh request should be sent. Second request should contain MFA code and access token obtained from initial response
     *
     * @tags Managed Account Authentication
     * @name V1TokenRefreshCreate
     * @summary Refresh auth token
     * @request POST:/api/v1/token/refresh
     * @secure
     * @response `200` `B2BBrokerRefreshTokenResponseApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1TokenRefreshCreate: (data: BrokerRefreshTokenRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerRefreshTokenResponseApiResult, ApiResult>({
        path: `/api/v1/token/refresh`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Remove connection to the financial institution and erase all related data completely.
     *
     * @tags Managed Account Authentication
     * @name V1AccountDelete
     * @summary Remove connection
     * @request DELETE:/api/v1/account
     * @secure
     * @response `200` `ApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1AccountDelete: (data: BrokerBaseRequest, params: RequestParams = {}) =>
      this.request<ApiResult, ApiResult>({
        path: `/api/v1/account`,
        method: 'DELETE',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get the list of supported institutions and their health statuses.
     *
     * @tags Managed Account Authentication
     * @name V1StatusList
     * @summary Get health status
     * @request GET:/api/v1/status
     * @secure
     * @response `200` `B2BBrokersHealthStatusListApiResult` OK
     * @response `401` `any` Unauthorized
     */
    v1StatusList: (params: RequestParams = {}) =>
      this.request<B2BBrokersHealthStatusListApiResult, any>({
        path: `/api/v1/status`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description Returns a list of integrations with details including the integration ID, name, type, DeFi wallet provider ID, and categories.
     *
     * @tags Managed Account Authentication
     * @name V1IntegrationsList
     * @summary Retrieve the list of all available integrations.
     * @request GET:/api/v1/integrations
     * @secure
     * @response `200` `IntegrationsResponseApiResult` OK
     */
    v1IntegrationsList: (params: RequestParams = {}) =>
      this.request<IntegrationsResponseApiResult, any>({
        path: `/api/v1/integrations`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      })
  }
  selfManagedAccountAuthentication = {
    /**
     * @description Get authentication schemes of available integrations to perform authentication programmatically (not using the Web Catalog UI).
     *
     * @tags Self Managed Account Authentication
     * @name V1AuthenticationSchemesList
     * @summary Get authentication schemes
     * @request GET:/api/v1/authenticationSchemes
     * @secure
     * @response `200` `BrokerAuthenticationSchemeIReadOnlyCollectionApiResult` OK
     * @response `401` `any` Unauthorized
     */
    v1AuthenticationSchemesList: (params: RequestParams = {}) =>
      this.request<BrokerAuthenticationSchemeIReadOnlyCollectionApiResult, any>({
        path: `/api/v1/authenticationSchemes`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description Authenticate user's brokerage/exchange account programmatically (not using the Web Catalog UI)
     *
     * @tags Self Managed Account Authentication
     * @name V1AuthenticateCreate
     * @summary Authenticate user's account
     * @request POST:/api/v1/authenticate
     * @secure
     * @response `200` `B2BBrokerAuthResponseApiResult` OK
     * @response `400` `ProblemDetails` Bad Request
     * @response `500` `void` Internal Server Error
     * @response `503` `void` Service Unavailable
     */
    v1AuthenticateCreate: (
      query: {
        /**
         * Id of the end-user
         * @maxLength 50
         */
        userId: string
      },
      data: B2BBrokerAuthRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerAuthResponseApiResult, ProblemDetails | void>({
        path: `/api/v1/authenticate`,
        method: 'POST',
        query: query,
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get OAuth link for the integrations with `OAuth` AuthenticationSchemeType
     *
     * @tags Self Managed Account Authentication
     * @name V1AuthenticateDetail
     * @summary Get OAuth authentication link
     * @request GET:/api/v1/authenticate/{brokerType}
     * @secure
     * @response `200` `B2BBrokerAuthPromptResponseApiResult` OK
     * @response `400` `ProblemDetails` Bad Request
     */
    v1AuthenticateDetail: (
      brokerType:
        | 'robinhood'
        | 'eTrade'
        | 'alpaca'
        | 'tdAmeritrade'
        | 'weBull'
        | 'stash'
        | 'interactiveBrokers'
        | 'public'
        | 'coinbase'
        | 'kraken'
        | 'coinbasePro'
        | 'cryptoCom'
        | 'openSea'
        | 'binanceUs'
        | 'gemini'
        | 'cryptocurrencyAddress'
        | 'cryptocurrencyWallet'
        | 'okCoin'
        | 'bittrex'
        | 'kuCoin'
        | 'etoro'
        | 'cexIo'
        | 'binanceInternational'
        | 'bitstamp'
        | 'gateIo'
        | 'acorns'
        | 'okx'
        | 'bitFlyer'
        | 'coinlist'
        | 'huobi'
        | 'bitfinex'
        | 'deFiWallet'
        | 'krakenDirect'
        | 'vanguard'
        | 'binanceInternationalDirect'
        | 'bitfinexDirect'
        | 'bybit'
        | 'paxos'
        | 'coinbasePrime'
        | 'btcTurkDirect'
        | 'kuCoinDirect'
        | 'okxOAuth'
        | 'paribuDirect'
        | 'robinhoodConnect'
        | 'blockchainCom'
        | 'bitsoDirect'
        | 'binanceConnect'
        | 'binanceOAuth'
        | 'revolutConnect'
        | 'binancePay'
        | 'bybitDirect'
        | 'paribuOAuth'
        | 'payPalConnect',
      query: {
        /** Id of the end-user */
        userId: string
      },
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerAuthPromptResponseApiResult, ProblemDetails>({
        path: `/api/v1/authenticate/${brokerType}`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      })
  }
  managedTransfers = {
    /**
     * @description **Get supported networks list.** --- Get the list of all networks supported by Mesh to perform transfers, including which tokens and integrations are supported.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedNetworksList
     * @summary Get networks
     * @request GET:/api/v1/transfers/managed/networks
     * @secure
     * @response `200` `NetworkModelResponseApiResult` OK
     * @response `401` `any` Unauthorized
     */
    v1TransfersManagedNetworksList: (params: RequestParams = {}) =>
      this.request<NetworkModelResponseApiResult, any>({
        path: `/api/v1/transfers/managed/networks`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description **Get supported integrations list.** --- Get the list of all integrations supported by Mesh to perform transfers, including which tokens and networks are supported.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedIntegrationsList
     * @summary Get integrations
     * @request GET:/api/v1/transfers/managed/integrations
     * @secure
     * @response `200` `IntegrationNetworkResponseApiResult` OK
     * @response `401` `any` Unauthorized
     */
    v1TransfersManagedIntegrationsList: (params: RequestParams = {}) =>
      this.request<IntegrationNetworkResponseApiResult, any>({
        path: `/api/v1/transfers/managed/integrations`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description Get the list of all tokens supported by Mesh to perform transfers, including which networks and integrations are supported.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedTokensList
     * @summary Get supported tokens list
     * @request GET:/api/v1/transfers/managed/tokens
     * @secure
     * @response `200` `TokenNetworksResponseApiResult` OK
     */
    v1TransfersManagedTokensList: (params: RequestParams = {}) =>
      this.request<TokenNetworksResponseApiResult, any>({
        path: `/api/v1/transfers/managed/tokens`,
        method: 'GET',
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description Checks if the combination of integration ID, network ID, token is correct for transfer. Checks if the target address is in the correct format.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedVerifyList
     * @summary Verify the transfer request without authenticating the integration accounts
     * @request GET:/api/v1/transfers/managed/verify
     * @secure
     * @response `200` `TransferVerificationResponseApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     */
    v1TransfersManagedVerifyList: (data: TransferVerificationRequest, params: RequestParams = {}) =>
      this.request<TransferVerificationResponseApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/verify`,
        method: 'GET',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description **Get the list of networks and tokens eligible for a transfer, based on the provided request data.** --- Transfers can be configured either from one connected account to another connected account, or from a connected account to any arbitrary address or addresses. * **From one connected account to another connected account:** The API client provides `FromAuthToken` that is representing the source account and `ToAuthToken` that is representing the target account. Front API maps networks and tokens supported by both accounts and returns all tokens and networks eligible for a transfer as the result. * **From a connected account to any arbitrary address:** The API client provides `FromAuthToken` that is representing the source account and the list of target addresses using the `ToAddresses` field. Front API verifies the addresses and returns the list of tokens, eligible to be transferred as the result of the operation. Returns the list of holdings on the account that can be used to perform the transfer. Each holdings item contains the list of supported networks that can be used to transfer the corresponding asset. Each network contains details such as gas fees and the amount eligible to be transferred.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedConfigureCreate
     * @summary Configure transfer
     * @request POST:/api/v1/transfers/managed/configure
     * @secure
     * @response `200` `ConfigureTransferResponseApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     * @response `403` `any` The API key used does not have write permission to call this Mesh endpoint.
     */
    v1TransfersManagedConfigureCreate: (data: ConfigureTransferRequest, params: RequestParams = {}) =>
      this.request<ConfigureTransferResponseApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/configure`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description **Validate and preview the transfer.** --- Validates the transfer, calculates the relevant amount in crypto if requested amount was in fiat and updates the current network fee values. This endpoint uses the `NetworkId` field to specify which network will be used to perform the transfer. The target `NetworkId` should be selected after configuring the transfer using `/configure` endpoint. Returns the `PreviewId` value that can be used to commit the transfer.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedPreviewCreate
     * @summary Preview transfer
     * @request POST:/api/v1/transfers/managed/preview
     * @secure
     * @response `200` `PreviewTransferResponseApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     * @response `403` `any` The API key used does not have write permission to call this Mesh endpoint.
     */
    v1TransfersManagedPreviewCreate: (data: PreviewTransferRequest, params: RequestParams = {}) =>
      this.request<PreviewTransferResponseApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/preview`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description **Commit the previously previewed transfer.** --- Previews the transfer, using the `PreviewId` value. Handles multi-factor authentication codes if the account is configured to use them for additional security. Returns the status of the transfer and the details of the transfer if it was initiated successfully.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedExecuteCreate
     * @summary Execute transfer
     * @request POST:/api/v1/transfers/managed/execute
     * @secure
     * @response `200` `ExecuteTransferResponseApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     * @response `403` `any` The API key used does not have write permission to call this Mesh endpoint.
     */
    v1TransfersManagedExecuteCreate: (data: ExecuteTransferRequest, params: RequestParams = {}) =>
      this.request<ExecuteTransferResponseApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/execute`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedAddressGetCreate
     * @summary Get deposit address
     * @request POST:/api/v1/transfers/managed/address/get
     * @secure
     * @response `200` `B2BBrokerCryptocurrencyDepositAddressResponseApiResult` Address successfully obtained or generation initiated.
     * @response `400` `ApiResult` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` Address for the required symbol is not found.
     */
    v1TransfersManagedAddressGetCreate: (
      data: ManagedBrokerCryptocurrencyDepositAddressRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerCryptocurrencyDepositAddressResponseApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/address/get`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get a quote for transferring a fiat amount from a brokerage account in a given cryptocurrency over a specified network. Returns min and max fees and amounts to account for different funding sources (existing crypto balance, cash balance or ACH/debit deposit). Currently only supported for Coinbase.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedQuoteCreate
     * @summary Quote transfer
     * @request POST:/api/v1/transfers/managed/quote
     * @secure
     * @response `200` `QuoteTransferResponseApiResult` Quote obtained.
     * @response `400` `ApiResult` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     */
    v1TransfersManagedQuoteCreate: (data: QuoteTransferRequest, params: RequestParams = {}) =>
      this.request<QuoteTransferResponseApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/quote`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get cryptocurrency transfers initiated by Mesh on exchanges or self-custody wallets.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedMeshList
     * @summary Get transfers initiated by Mesh
     * @request GET:/api/v1/transfers/managed/mesh
     * @secure
     * @response `200` `TransferModelPaginationResponseApiResult` Transfers obtained.
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     */
    v1TransfersManagedMeshList: (
      query?: {
        /**
         * Number of items to return. Default 10, maximum - 100.
         * @format int32
         */
        Count?: number
        /**
         * Number of items to skip.
         * @format int32
         */
        Offset?: number
        /**
         * Mesh transfer identifier.
         * @format uuid
         */
        Id?: string
        /**
         * Client transaction identifier.
         * @minLength 0
         * @maxLength 128
         */
        ClientTransactionId?: string
        /**
         * Client's user identifier.
         * @minLength 0
         * @maxLength 50
         */
        UserId?: string
        /**
         * Transfered integration.
         * @maxItems 100
         */
        IntegrationIds?: string[]
        /**
         * Transfer statuses.
         * @maxItems 5
         */
        Statuses?: TransferStatus[]
        /**
         * Transfer created minimum timestamp.
         * @format int64
         */
        FromTimestamp?: number
        /**
         * Transfer created maximum timestamp.
         * @format int64
         */
        ToTimestamp?: number
        /**
         * Minimum amount in fiat.
         * @format double
         */
        MinAmountInFiat?: number
        /**
         * Maximum amount in fiat.
         * @format double
         */
        MaxAmountInFiat?: number
        /** Order by column. */
        OrderBy?: TransferOrderByFields
        /** Value indicating if ordering is descending. */
        DescendingOrder?: boolean
      },
      params: RequestParams = {}
    ) =>
      this.request<TransferModelPaginationResponseApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/mesh`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      }),

    /**
     * @description **Updates the previously executed transfer.** --- Updates the transfer status, using the `TransactionId` value. Returns the status of the transfer and the details of the transfer.
     *
     * @tags Managed Transfers
     * @name V1TransfersManagedUpdateCreate
     * @summary Update transfer status
     * @request POST:/api/v1/transfers/managed/update
     * @secure
     * @response `200` `UpdateTransferResponseApiResult` OK
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized
     * @response `403` `any` The API key used does not have write permission to call this Mesh endpoint.
     */
    v1TransfersManagedUpdateCreate: (data: UpdateTransferStatusRequest, params: RequestParams = {}) =>
      this.request<UpdateTransferResponseApiResult, ApiResult>({
        path: `/api/v1/transfers/managed/update`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      })
  }
  portfolio = {
    /**
     * @description Obtain assets from the connected investment account. Performs realtime API call to the underlying integration.
     *
     * @tags Portfolio
     * @name V1HoldingsGetCreate
     * @summary Get holdings.
     * @request POST:/api/v1/holdings/get
     * @secure
     * @response `200` `HoldingsModelApiResult` Holdings obtained
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `403` `any` The API key used does not have read permission to call this Mesh endpoint.
     */
    v1HoldingsGetCreate: (data: PortfolioHoldingsRequest, params: RequestParams = {}) =>
      this.request<HoldingsModelApiResult, ApiResult>({
        path: `/api/v1/holdings/get`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Obtain assets from the connected investment account and return total value and performance. Performs realtime API call to the underlying integration.
     *
     * @tags Portfolio
     * @name V1HoldingsValueCreate
     * @summary Get holdings values.
     * @request POST:/api/v1/holdings/value
     * @secure
     * @response `200` `BrokerPortfolioValueModelApiResult` Market values of assets
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `403` `any` The API key used does not have read permission to call this Mesh endpoint.
     */
    v1HoldingsValueCreate: (data: PortfolioBrokerBaseRequest, params: RequestParams = {}) =>
      this.request<BrokerPortfolioValueModelApiResult, ApiResult>({
        path: `/api/v1/holdings/value`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get the aggregated portfolio of the user containing market values.
     *
     * @tags Portfolio
     * @name V1HoldingsPortfolioList
     * @summary Get aggregated portfolio
     * @request GET:/api/v1/holdings/portfolio
     * @secure
     * @response `200` `B2BPortfolioModelApiResult` Portfolio obtained
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `403` `any` The API key used does not have read permission to call this Mesh endpoint.
     */
    v1HoldingsPortfolioList: (
      query: {
        /** End user ID to get the aggregated portfolio for. */
        UserId: string
        /**
         * Offset in second, used to calculate daily return for cryptocurrencies.
         * @format int64
         */
        TimezoneOffset?: number
      },
      params: RequestParams = {}
    ) =>
      this.request<B2BPortfolioModelApiResult, ApiResult>({
        path: `/api/v1/holdings/portfolio`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      })
  }
  transactions = {
    /**
     * @description Get transactions on the account - the paginated history of the executed orders along with the pending orders.
     *
     * @tags Transactions
     * @name V1TransactionsListCreate
     * @summary Get transactions
     * @request POST:/api/v1/transactions/list
     * @secure
     * @response `200` `B2BBrokerOrderListResponseApiResult` Transactions obtained.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     * @response `403` `any` The API key used does not have read permission to call this Mesh endpoint.
     */
    v1TransactionsListCreate: (data: TransactionsB2BBrokerOrderListRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerOrderListResponseApiResult, any>({
        path: `/api/v1/transactions/list`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get details of an executed order. Typically used to poll the status of the previously executed order.
     *
     * @tags Transactions
     * @name V1TransactionsDetailsCreate
     * @summary Get transaction details
     * @request POST:/api/v1/transactions/details
     * @secure
     * @response `200` `B2BBrokerOrderApiResult` Transactions obtained.
     * @response `400` `ProblemDetails` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     * @response `403` `any` The API key used does not have read permission to call this Mesh endpoint.
     * @response `404` `ProblemDetails` Transaction is not found.
     */
    v1TransactionsDetailsCreate: (data: TransactionsB2BBrokerOrderRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerOrderApiResult, ProblemDetails>({
        path: `/api/v1/transactions/details`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get supported features for trading for a particular financial institution. Different institutions support different features (e.g. different `OrderType` or different sets of `TimeInForce` values), so this endpoint is used to describe such features for provided financial institution.
     *
     * @tags Transactions
     * @name V1TransactionsFeatureListCreate
     * @summary Get supported order features for institution
     * @request POST:/api/v1/transactions/featureList
     * @secure
     * @response `200` `B2BBrokerTradingFeatureInfoApiResult` Feature list obtained.
     * @response `400` `ProblemDetails` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     */
    v1TransactionsFeatureListCreate: (data: TransactionsBrokerBaseRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerTradingFeatureInfoApiResult, ProblemDetails>({
        path: `/api/v1/transactions/featureList`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Validates the order information (such as necessary balance availability), and returns additional information, such as expected order fee. Does not execute the order.
     *
     * @tags Transactions
     * @name V1TransactionsPreviewCreate
     * @summary Preview order execution
     * @request POST:/api/v1/transactions/preview/{side}
     * @secure
     * @response `200` `B2BBrokerPreviewOrderResultApiResult` Order preview obtained.
     * @response `400` `ProblemDetails` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     * @response `403` `any` The API key used does not have write permission to call this Mesh endpoint.
     */
    v1TransactionsPreviewCreate: (
      side: 'unknown' | 'buy' | 'sell',
      data: TransactionsB2BBrokerCreateOrderRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerPreviewOrderResultApiResult, ProblemDetails>({
        path: `/api/v1/transactions/preview/${side}`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Validates the order information and then calls institution's API to execute an order. It's recommended to call this endpoint after calling the `preview` endpoint to make sure that the order execution request is correct.
     *
     * @tags Transactions
     * @name V1TransactionsCreate
     * @summary Execute order
     * @request POST:/api/v1/transactions/{side}
     * @secure
     * @response `200` `B2BBrokerCreateOrderResultApiResult` Order executed.
     * @response `400` `ProblemDetails` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     * @response `403` `any` The API key used does not have write permission to call this Mesh endpoint.
     */
    v1TransactionsCreate: (
      side: 'unknown' | 'buy' | 'sell',
      data: TransactionsB2BBrokerCreateOrderRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerCreateOrderResultApiResult, ProblemDetails>({
        path: `/api/v1/transactions/${side}`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Cancels a pending order (an order with `InProgress` status). `SymbolPair` is required to be provided for `Binance`, `BinanceInternational`, `Okx` and `BitFlyer` institutions. This value
     *
     * @tags Transactions
     * @name V1TransactionsCancelCreate
     * @summary Cancel order execution
     * @request POST:/api/v1/transactions/cancel
     * @secure
     * @response `200` `ApiResult` Order canceled.
     * @response `400` `ProblemDetails` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or provided integration token is not correct.
     * @response `403` `any` The API key used does not have write permission to call this Mesh endpoint.
     * @response `404` `ProblemDetails` Not Found
     */
    v1TransactionsCancelCreate: (data: TransactionsB2BBrokerOrderRequest, params: RequestParams = {}) =>
      this.request<ApiResult, ProblemDetails>({
        path: `/api/v1/transactions/cancel`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Returns information on trading allowance for a provided symbol. For example - some institutions allow fractional trading for some symbols, but do not allow it for others. So before placing an order the API client can check if the required symbol can be traded fractionally with the provided institution.
     *
     * @tags Transactions
     * @name V1TransactionsSymbolinfoCreate
     * @summary Get symbol information
     * @request POST:/api/v1/transactions/symbolinfo
     * @secure
     * @response `200` `B2BBrokerOrderSymbolInfoApiResult` Information for symbol obtained.
     * @response `400` `ProblemDetails` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct.
     */
    v1TransactionsSymbolinfoCreate: (
      data: TransactionsB2BBrokerSymbolInfoForOrderRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerOrderSymbolInfoApiResult, ProblemDetails>({
        path: `/api/v1/transactions/symbolinfo`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      })
  }
  transfers = {
    /**
     * @description Get entire history of cryptocurrency transfers (withdrawals or deposits) executed from an exchange. Only supports Exchange integrations.
     *
     * @tags Transfers
     * @name V1TransfersListCreate
     * @summary Get transfer history
     * @request POST:/api/v1/transfers/list
     * @secure
     * @response `200` `B2BBrokerTransactionsListModelApiResult` Transfers obtained.
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `403` `any` The API key used does not have read permission to call this Mesh endpoint.
     */
    v1TransfersListCreate: (data: TransfersBrokerTransactionsListRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerTransactionsListModelApiResult, ApiResult>({
        path: `/api/v1/transfers/list`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get details of a specific transfer (withdrawals or deposits) executed from an exchange. Only supports Exchange integrations.
     *
     * @tags Transfers
     * @name V1TransfersDetailsCreate
     * @summary Get transfer details
     * @request POST:/api/v1/transfers/details
     * @secure
     * @response `200` `B2BBrokerCryptocurrencyTransactionApiResult` Transfer details obtained.
     * @response `400` `ApiResult` Transfer details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `403` `any` The API key used does not have read permission to call this Mesh endpoint.
     * @response `404` `ApiResult` Transfer with provided id was not found.
     */
    v1TransfersDetailsCreate: (
      data: TransfersBrokerCryptocurrencyTransactionDetailsRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerCryptocurrencyTransactionApiResult, ApiResult>({
        path: `/api/v1/transfers/details`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Initiate a new cryptocurrency transfer on a blockchain, cryptocurrency broker or cryptocurrency exchange. Obsolete endpoint, please use POST /transfers/managed/execute endpoint instead.
     *
     * @tags Transfers
     * @name V1TransfersCreate
     * @summary Initiate a transfer
     * @request POST:/api/v1/transfers
     * @deprecated
     * @secure
     * @response `200` `B2BBrokerCreateCryptocurrencyTransactionResponseApiResult` Transfer successfully initiated.
     * @response `400` `ApiResult` Transfer details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `403` `any` The API key used does not have write permission to call this Mesh endpoint.
     */
    v1TransfersCreate: (data: TransfersBrokerCreateCryptocurrencyTransactionRequest, params: RequestParams = {}) =>
      this.request<B2BBrokerCreateCryptocurrencyTransactionResponseApiResult, ApiResult>({
        path: `/api/v1/transfers`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get or generate a cryptocurrency deposit address that can be used to transfer assets to the financial institution
     *
     * @tags Transfers
     * @name V1TransfersAddressGetCreate
     * @summary Get deposit address
     * @request POST:/api/v1/transfers/address/get
     * @secure
     * @response `200` `B2BBrokerCryptocurrencyDepositAddressResponseApiResult` Address successfully obtained or generation initiated.
     * @response `400` `ApiResult` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` Address for the required symbol is not found.
     */
    v1TransfersAddressGetCreate: (
      data: TransfersBrokerCryptocurrencyDepositAddressRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerCryptocurrencyDepositAddressResponseApiResult, ApiResult>({
        path: `/api/v1/transfers/address/get`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      }),

    /**
     * @description Get details of the asset for deposit or withdrawal. For example, several exchanges support same tokens over multiple blockchains, and thus require the name of chain to be supplied for transfers. This endpoint allows getting such details.
     *
     * @tags Transfers
     * @name V1TransfersSymbolDetailsCreate
     * @summary Get details of asset
     * @request POST:/api/v1/transfers/symbol/details
     * @secure
     * @response `200` `B2BBrokerCryptocurrencySymbolDetailsResponseApiResult` Address successfully obtained or generation initiated.
     * @response `400` `ApiResult` Request details are not correct.
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     * @response `404` `ApiResult` Asset details for provided symbol are not found.
     */
    v1TransfersSymbolDetailsCreate: (
      data: TransfersBrokerCryptocurrencyDepositAddressRequest,
      params: RequestParams = {}
    ) =>
      this.request<B2BBrokerCryptocurrencySymbolDetailsResponseApiResult, ApiResult>({
        path: `/api/v1/transfers/symbol/details`,
        method: 'POST',
        body: data,
        secure: true,
        type: ContentType.Json,
        format: 'json',
        ...params
      })
  }
  wallets = {
    /**
     * No description
     *
     * @tags Wallets
     * @name V1WalletsVerifyList
     * @summary Get wallet verifications for user and address.
     * @request GET:/api/v1/wallets/verify
     * @secure
     * @response `200` `DeFiWalletVerificationResponseApiResult` Verifications obtained.
     * @response `400` `ApiResult` Bad Request
     * @response `401` `any` Unauthorized: Client Id or Client Secret are not correct or missing.
     */
    v1WalletsVerifyList: (
      query?: {
        /** User identifier. */
        UserId?: string
        /** Address of the wallet. */
        Address?: string
      },
      params: RequestParams = {}
    ) =>
      this.request<DeFiWalletVerificationResponseApiResult, ApiResult>({
        path: `/api/v1/wallets/verify`,
        method: 'GET',
        query: query,
        secure: true,
        format: 'json',
        ...params
      })
  }
}
